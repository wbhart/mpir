This is mpir.info, produced by makeinfo version 5.2 from mpir.texi.

This manual describes how to install and use MPIR, the Multiple
Precision Integers and Rationals library, version 3.0.0.

   Copyright 1991, 1993-2016 Free Software Foundation, Inc.

   Copyright 2008, 2009, 2010 William Hart

   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with the Front-Cover Texts being "A GNU Manual", and
with the Back-Cover Texts being "You have freedom to copy and modify
this GNU Manual, like GNU software".  A copy of the license is included
in *note GNU Free Documentation License::.
INFO-DIR-SECTION GNU libraries
START-INFO-DIR-ENTRY
* mpir: (mpir).                   MPIR Multiple Precision Integers and Rationals Library.
END-INFO-DIR-ENTRY


File: mpir.info,  Node: Top,  Next: Copying,  Prev: (dir),  Up: (dir)

MPIR
****

This manual describes how to install and use MPIR, the Multiple
Precision Integers and Rationals library, version 3.0.0.

   Copyright 1991, 1993-2016 Free Software Foundation, Inc.

   Copyright 2008, 2009, 2010 William Hart

   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with the Front-Cover Texts being "A GNU Manual", and
with the Back-Cover Texts being "You have freedom to copy and modify
this GNU Manual, like GNU software".  A copy of the license is included
in *note GNU Free Documentation License::.

* Menu:

* Copying::                    MPIR Copying Conditions (LGPL).
* Introduction to MPIR::       Brief introduction to MPIR.
* Installing MPIR::            How to configure and compile the MPIR library.
* MPIR Basics::                What every MPIR user should know.
* Reporting Bugs::             How to usefully report bugs.
* Integer Functions::          Functions for arithmetic on signed integers.
* Rational Number Functions::  Functions for arithmetic on rational numbers.
* Floating-point Functions::   Functions for arithmetic on floats.
* Low-level Functions::        Fast functions for natural numbers.
* Random Number Functions::    Functions for generating random numbers.
* Formatted Output::           'printf' style output.
* Formatted Input::            'scanf' style input.
* C++ Class Interface::        Class wrappers around MPIR types.
* .Net Interface::             Managed .Net wrappers for MPIR types.
* Custom Allocation::          How to customize the internal allocation.
* Language Bindings::          Using MPIR from other languages.
* Algorithms::                 What happens behind the scenes.
* Internals::                  How values are represented behind the scenes.

* Contributors::	       Who brings you this library?
* References::                 Some useful papers and books to read.
* GNU Free Documentation License::
* Concept Index::
* Function Index::


File: mpir.info,  Node: Copying,  Next: Introduction to MPIR,  Prev: Top,  Up: Top

MPIR Copying Conditions
***********************

This library is "free"; this means that everyone is free to use it and
free to redistribute it on a free basis.  The library is not in the
public domain; it is copyrighted and there are restrictions on its
distribution, but these restrictions are designed to permit everything
that a good cooperating citizen would want to do.  What is not allowed
is to try to prevent others from further sharing any version of this
library that they might get from you.

   Specifically, we want to make sure that you have the right to give
away copies of the library, that you receive source code or else can get
it if you want it, that you can change this library or use pieces of it
in new free programs, and that you know you can do these things.

   To make sure that everyone has such rights, we have to forbid you to
deprive anyone else of these rights.  For example, if you distribute
copies of the MPIR library, you must give the recipients all the rights
that you have.  You must make sure that they, too, receive or can get
the source code.  And you must tell them their rights.

   Also, for our own protection, we must make certain that everyone
finds out that there is no warranty for the MPIR library.  If it is
modified by someone else and passed on, we want their recipients to know
that what they have is not what we distributed, so that any problems
introduced by others will not reflect on our reputation.

   The precise conditions of the license for the MPIR library are found
in the Lesser General Public License version 3 that accompanies the
source code, see 'COPYING.LIB'.


File: mpir.info,  Node: Introduction to MPIR,  Next: Installing MPIR,  Prev: Copying,  Up: Top

1 Introduction to MPIR
**********************

MPIR is a portable library written in C for arbitrary precision
arithmetic on integers, rational numbers, and floating-point numbers.
It aims to provide the fastest possible arithmetic for all applications
that need higher precision than is directly supported by the basic C
types.

   Many applications use just a few hundred bits of precision; but some
applications may need thousands or even millions of bits.  MPIR is
designed to give good performance for both, by choosing algorithms based
on the sizes of the operands, and by carefully keeping the overhead at a
minimum.

   The speed of MPIR is achieved by using fullwords as the basic
arithmetic type, by using sophisticated algorithms, by including
carefully optimized assembly code for the most common inner loops for
many different CPUs, and by a general emphasis on speed (as opposed to
simplicity or elegance).

   There is assembly code for these CPUs: ARM, DEC Alpha 21064, 21164,
and 21264, AMD K6, K6-2, Athlon, K8 and K10, Intel Pentium, Pentium
Pro/II/III, Pentium 4, generic x86, Intel IA-64, Core 2, i7, Atom,
Motorola/IBM PowerPC 32 and 64, MIPS R3000, R4000, SPARCv7, SuperSPARC,
generic SPARCv8, UltraSPARC,

For up-to-date information on, and latest version of, MPIR, please see
the MPIR web pages at

     <http://www.mpir.org/>

   There are a number of public mailing lists of interest.  The
development list is

     <http://groups.google.com/group/mpir-devel/>.

   The proper place for bug reports is
<http://groups.google.com/group/mpir-devel>.  See *note Reporting Bugs::
for information about reporting bugs.


1.1 How to use this Manual
==========================

Everyone should read *note MPIR Basics::.  If you need to install the
library yourself, then read *note Installing MPIR::.  If you have a
system with multiple ABIs, then read *note ABI and ISA::, for the
compiler options that must be used on applications.  In addition to
usual compilation tools, MPIR depends on Yasm to be built.  If yasm is
not available on your system, you can download its sources at

     <http://yasm.tortall.net/Download.html>

   build your own version and make it available to MPIR configuration
system by passing its path to 'configure' through the '--with-yasm'
option.  See *note Build Options:: for further details.

   The rest of the manual can be used for later reference, although it
is probably a good idea to glance through it.


File: mpir.info,  Node: Installing MPIR,  Next: MPIR Basics,  Prev: Introduction to MPIR,  Up: Top

2 Installing MPIR
*****************

MPIR has an autoconf/automake/libtool based configuration system.  On a
Unix-like system a basic build can be done with

     ./configure
     make

Some self-tests can be run with

     make check

And you can install (under '/usr/local' by default) with

     make install

   Important note: by default MPIR produces libraries named libmpir,
etc., and the header file 'mpir.h'.  If you wish to have MPIR to build a
library named libgmp as well, etc., and a 'gmp.h' header file, so that
you can use mpir with programs designed to only work with GMP, then use
the '--enable-gmpcompat' option when invoking configure:

     ./configure --enable-gmpcompat

   Note 'gmp.h' is only created upon running make install.

   MPIR is compatible with GMP when the '--enable-gmpcompat' option is
used, except that the GMP secure cryptographic functions are not
available.

   Some deprecated GMP functionality may be unavailable if this option
is not selected.

   If you experience problems, please report them to

   <http://groups.google.com/group/mpir-devel>.

   See *note Reporting Bugs::, for information on what to include in
useful bug reports.

* Menu:

* Build Options::
* ABI and ISA::
* Notes for Package Builds::
* Building with Microsoft Visual Studio::
* Notes for Particular Systems::
* Known Build Problems::
* Performance optimization::


File: mpir.info,  Node: Build Options,  Next: ABI and ISA,  Prev: Installing MPIR,  Up: Installing MPIR

2.1 Build Options
=================

All the usual autoconf configure options are available, run './configure
--help' for a summary.  The file 'INSTALL.autoconf' has some generic
installation information too.

Tools
     'configure' requires various Unix-like tools.  See *note Notes for
     Particular Systems::, for some options on non-Unix systems.

     It might be possible to build without the help of 'configure',
     certainly all the code is there, but unfortunately you'll be on
     your own.

Build Directory
     To compile in a separate build directory, 'cd' to that directory,
     and prefix the configure command with the path to the MPIR source
     directory.  For example

          cd /my/build/dir
          /my/sources/mpir-3.0.0/configure

     Not all 'make' programs have the necessary features ('VPATH') to
     support this.  In particular, SunOS and Solaris 'make' have bugs
     that make them unable to build in a separate directory.  Use GNU
     'make' instead.

'--prefix' and '--exec-prefix'
     The '--prefix' option can be used in the normal way to direct MPIR
     to install under a particular tree.  The default is '/usr/local'.

     '--exec-prefix' can be used to direct architecture-dependent files
     like 'libmpir.a' to a different location.  This can be used to
     share architecture-independent parts like the documentation, but
     separate the dependent parts.  Note however that 'mpir.h' and
     'mp.h' are architecture-dependent since they encode certain aspects
     of 'libmpir', so it will be necessary to ensure both
     '$prefix/include' and '$exec_prefix/include' are available to the
     compiler.

'--enable-gmpcompat'
     By default make builds libmpir library files (and libmpirxx if C++
     headers are requested) and the 'mpir.h' header file.  This option
     allows you to specify that you want additional libraries created
     called libgmp (and libgmpxx), etc., for libraries and gmp.h for
     compatibility with GMP (except for GMP secure cryptograhic
     functions, which are not available in MPIR).

'--disable-shared', '--disable-static'
     By default both shared and static libraries are built (where
     possible), but one or other can be disabled.  Shared libraries
     result in smaller executables and permit code sharing between
     separate running processes, but on some CPUs are slightly slower,
     having a small cost on each function call.

Native Compilation, '--build=CPU-VENDOR-OS'
     For normal native compilation, the system can be specified with
     '--build'.  By default './configure' uses the output from running
     './config.guess'.  On some systems './config.guess' can determine
     the exact CPU type, on others it will be necessary to give it
     explicitly.  For example,

          ./configure --build=ultrasparc-sun-solaris2.7

     In all cases the 'OS' part is important, since it controls how
     libtool generates shared libraries.  Running './config.guess' is
     the simplest way to see what it should be, if you don't know
     already.

Cross Compilation, '--host=CPU-VENDOR-OS'
     When cross-compiling, the system used for compiling is given by
     '--build' and the system where the library will run is given by
     '--host'.  For example when using a FreeBSD Athlon system to build
     GNU/Linux m68k binaries,

          ./configure --build=athlon-pc-freebsd3.5 --host=m68k-mac-linux-gnu

     Compiler tools are sought first with the host system type as a
     prefix.  For example 'm68k-mac-linux-gnu-ranlib' is tried, then
     plain 'ranlib'.  This makes it possible for a set of
     cross-compiling tools to co-exist with native tools.  The prefix is
     the argument to '--host', and this can be an alias, such as
     'm68k-linux'.  But note that tools don't have to be setup this way,
     it's enough to just have a 'PATH' with a suitable cross-compiling
     'cc' etc.

     Compiling for a different CPU in the same family as the build
     system is a form of cross-compilation, though very possibly this
     would merely be special options on a native compiler.  In any case
     './configure' avoids depending on being able to run code on the
     build system, which is important when creating binaries for a newer
     CPU since they very possibly won't run on the build system.

     In all cases the compiler must be able to produce an executable (of
     whatever format) from a standard C 'main'.  Although only object
     files will go to make up 'libmpir', './configure' uses linking
     tests for various purposes, such as determining what functions are
     available on the host system.

     Currently a warning is given unless an explicit '--build' is used
     when cross-compiling, because it may not be possible to correctly
     guess the build system type if the 'PATH' has only a
     cross-compiling 'cc'.

     Note that the '--target' option is not appropriate for MPIR.  It's
     for use when building compiler tools, with '--host' being where
     they will run, and '--target' what they'll produce code for.
     Ordinary programs or libraries like MPIR are only interested in the
     '--host' part, being where they'll run.

CPU types
     In general, if you want a library that runs as fast as possible,
     you should configure MPIR for the exact CPU type your system uses.
     However, this may mean the binaries won't run on older members of
     the family, and might run slower on other members, older or newer.
     The best idea is always to build MPIR for the exact machine type
     you intend to run it on.

     The following CPUs have specific support.  See 'configure.in' for
     details of what code and compiler options they select.

        * Alpha: alpha, alphaev5, alphaev56, alphapca56, alphapca57,
          alphaev6, alphaev67, alphaev68 alphaev7

        * IA-64: ia64, itanium, itanium2

        * MIPS: mips, mips3, mips64

        * PowerPC: powerpc, powerpc64, powerpc401, powerpc403,
          powerpc405, powerpc505, powerpc601, powerpc602, powerpc603,
          powerpc603e, powerpc604, powerpc604e, powerpc620, powerpc630,
          powerpc740, powerpc7400, powerpc7450, powerpc750, powerpc801,
          powerpc821, powerpc823, powerpc860, powerpc970

        * SPARC: sparc, sparcv8, microsparc, supersparc, sparcv9,
          ultrasparc, ultrasparc2, ultrasparc2i, ultrasparc3, sparc64

        * x86 family: pentium, pentiummmx, pentiumpro, pentium2,
          pentium3, pentium4, netburst, netburstlahf, prescott, core,
          core2, penryn, nehalem, westmere sandybridge haswell nano
          atom, k5, k6, k62, k63, k7, k8, k10 k102 piledriver bulldozer
          bobcat viac3, viac32

        * Other: arm,

     CPUs not listed will use generic C code.

Generic C Build
     If some of the assembly code causes problems, or if otherwise
     desired, the generic C code can be selected with CPU 'none'.  For
     example,

          ./configure --host=none-unknown-freebsd3.5

     Note that this will run quite slowly, but it should be portable and
     should at least make it possible to get something running if all
     else fails.

Fat binary, '--enable-fat'
     Using '--enable-fat' selects a "fat binary" build on x86 or x86_64
     systems, where optimized low level subroutines are chosen at
     runtime according to the CPU detected.  This means more code, but
     gives reasonable performance from a single binary for all x86
     chips, or similarly for all x86_64 chips.  (This option might
     become available for more architectures in the future.)

'ABI'
     On some systems MPIR supports multiple ABIs (application binary
     interfaces), meaning data type sizes and calling conventions.  By
     default MPIR chooses the best ABI available, but a particular ABI
     can be selected.  For example

          ./configure --host=mips64-sgi-irix6 ABI=n32

     See *note ABI and ISA::, for the available choices on relevant
     CPUs, and what applications need to do.

'--with-yasm'
     By default MPIR will look for a system-wide Yasm using the 'which'
     command.  Passing '--with-yasm' let MPIR use a version of Yasm at a
     non-standard location.  This is useful if none is available in
     'PATH'.  With this option a full path to Yasm's binary should be
     given, for example

          ./configure --with-yasm=/usr/local/bin/yasm

'CC', 'CFLAGS'
     By default the C compiler used is chosen from among some likely
     candidates, with 'gcc' normally preferred if it's present.  The
     usual 'CC=whatever' can be passed to './configure' to choose
     something different.

     For various systems, default compiler flags are set based on the
     CPU and compiler.  The usual 'CFLAGS="-whatever"' can be passed to
     './configure' to use something different or to set good flags for
     systems MPIR doesn't otherwise know.

     The 'CC' and 'CFLAGS' used are printed during './configure', and
     can be found in each generated 'Makefile'.  This is the easiest way
     to check the defaults when considering changing or adding
     something.

     Note that when 'CC' and 'CFLAGS' are specified on a system
     supporting multiple ABIs it's important to give an explicit
     'ABI=whatever', since MPIR can't determine the ABI just from the
     flags and won't be able to select the correct assembler code.

     If just 'CC' is selected then normal default 'CFLAGS' for that
     compiler will be used (if MPIR recognises it).  For example
     'CC=gcc' can be used to force the use of GCC, with default flags
     (and default ABI).

'CPPFLAGS'
     Any flags like '-D' defines or '-I' includes required by the
     preprocessor should be set in 'CPPFLAGS' rather than 'CFLAGS'.
     Compiling is done with both 'CPPFLAGS' and 'CFLAGS', but
     preprocessing uses just 'CPPFLAGS'.  This distinction is because
     most preprocessors won't accept all the flags the compiler does.
     Preprocessing is done separately in some configure tests, and in
     the 'ansi2knr' support for K&R compilers.

'CC_FOR_BUILD'
     Some build-time programs are compiled and run to generate
     host-specific data tables.  'CC_FOR_BUILD' is the compiler used for
     this.  It doesn't need to be in any particular ABI or mode, it
     merely needs to generate executables that can run.  The default is
     to try the selected 'CC' and some likely candidates such as 'cc'
     and 'gcc', looking for something that works.

     No flags are used with 'CC_FOR_BUILD' because a simple invocation
     like 'cc foo.c' should be enough.  If some particular options are
     required they can be included as for instance 'CC_FOR_BUILD="cc
     -whatever"'.

C++ Support, '--enable-cxx'
     C++ support in MPIR can be enabled with '--enable-cxx', in which
     case a C++ compiler will be required.  As a convenience
     '--enable-cxx=detect' can be used to enable C++ support only if a
     compiler can be found.  The C++ support consists of a library
     'libmpirxx.la' and header file 'mpirxx.h' (*note Headers and
     Libraries::).

     A separate 'libmpirxx.la' has been adopted rather than having C++
     objects within 'libmpir.la' in order to ensure dynamic linked C
     programs aren't bloated by a dependency on the C++ standard
     library, and to avoid any chance that the C++ compiler could be
     required when linking plain C programs.

     'libmpirxx.la' will use certain internals from 'libmpir.la' and can
     only be expected to work with 'libmpir.la' from the same MPIR
     version.  Future changes to the relevant internals will be
     accompanied by renaming, so a mismatch will cause unresolved
     symbols rather than perhaps mysterious misbehaviour.

     In general 'libmpirxx.la' will be usable only with the C++ compiler
     that built it, since name mangling and runtime support are usually
     incompatible between different compilers.

'CXX', 'CXXFLAGS'
     When C++ support is enabled, the C++ compiler and its flags can be
     set with variables 'CXX' and 'CXXFLAGS' in the usual way.  The
     default for 'CXX' is the first compiler that works from a list of
     likely candidates, with 'g++' normally preferred when available.
     The default for 'CXXFLAGS' is to try 'CFLAGS', 'CFLAGS' without
     '-g', then for 'g++' either '-g -O2' or '-O2', or for other
     compilers '-g' or nothing.  Trying 'CFLAGS' this way is convenient
     when using 'gcc' and 'g++' together, since the flags for 'gcc' will
     usually suit 'g++'.

     It's important that the C and C++ compilers match, meaning their
     startup and runtime support routines are compatible and that they
     generate code in the same ABI (if there's a choice of ABIs on the
     system).  './configure' isn't currently able to check these things
     very well itself, so for that reason '--disable-cxx' is the
     default, to avoid a build failure due to a compiler mismatch.
     Perhaps this will change in the future.

     Incidentally, it's normally not good enough to set 'CXX' to the
     same as 'CC'.  Although 'gcc' for instance recognises 'foo.cc' as
     C++ code, only 'g++' will invoke the linker the right way when
     building an executable or shared library from C++ object files.

Temporary Memory, '--enable-alloca=<choice>'
     MPIR allocates temporary workspace using one of the following three
     methods, which can be selected with for instance
     '--enable-alloca=malloc-reentrant'.

        * 'alloca' - C library or compiler builtin.
        * 'malloc-reentrant' - the heap, in a re-entrant fashion.
        * 'malloc-notreentrant' - the heap, with global variables.

     For convenience, the following choices are also available.
     '--disable-alloca' is the same as 'no'.

        * 'yes' - a synonym for 'alloca'.
        * 'no' - a synonym for 'malloc-reentrant'.
        * 'reentrant' - 'alloca' if available, otherwise
          'malloc-reentrant'.  This is the default.
        * 'notreentrant' - 'alloca' if available, otherwise
          'malloc-notreentrant'.

     'alloca' is reentrant and fast, and is recommended.  It actually
     allocates just small blocks on the stack; larger ones use
     malloc-reentrant.

     'malloc-reentrant' is, as the name suggests, reentrant and thread
     safe, but 'malloc-notreentrant' is faster and should be used if
     reentrancy is not required.

     The two malloc methods in fact use the memory allocation functions
     selected by 'mp_set_memory_functions', these being 'malloc' and
     friends by default.  *Note Custom Allocation::.

     An additional choice '--enable-alloca=debug' is available, to help
     when debugging memory related problems (*note Debugging::).

FFT Multiplication, '--disable-fft'
     By default multiplications are done using Karatsuba, Toom, and FFT
     algorithms.  The FFT is only used on large to very large operands
     and can be disabled to save code size if desired.

Assertion Checking, '--enable-assert'
     This option enables some consistency checking within the library.
     This can be of use while debugging, *note Debugging::.

Execution Profiling, '--enable-profiling=prof/gprof/instrument'
     Enable profiling support, in one of various styles, *note
     Profiling::.

'MPN_PATH'
     Various assembler versions of mpn subroutines are provided.  For a
     given CPU, a search is made though a path to choose a version of
     each.  For example 'sparcv8' has

          MPN_PATH="sparc32/v8 sparc32 generic"

     which means look first for v8 code, then plain sparc32 (which is
     v7), and finally fall back on generic C.  Knowledgeable users with
     special requirements can specify a different path.  Normally this
     is completely unnecessary.

Documentation
     The source for the document you're now reading is 'doc/mpir.texi',
     in Texinfo format, see *note Texinfo: (texinfo)Top.

     Info format 'doc/mpir.info' is included in the distribution.  The
     usual automake targets are available to make PostScript, DVI, PDF
     and HTML (these will require various TeX and Texinfo tools).

     DocBook and XML can be generated by the Texinfo 'makeinfo' program
     too, see *note Options for 'makeinfo': (texinfo)makeinfo options.

     Some supplementary notes can also be found in the 'doc'
     subdirectory.


File: mpir.info,  Node: ABI and ISA,  Next: Notes for Package Builds,  Prev: Build Options,  Up: Installing MPIR

2.2 ABI and ISA
===============

ABI (Application Binary Interface) refers to the calling conventions
between functions, meaning what registers are used and what sizes the
various C data types are.  ISA (Instruction Set Architecture) refers to
the instructions and registers a CPU has available.

   Some 64-bit ISA CPUs have both a 64-bit ABI and a 32-bit ABI defined,
the latter for compatibility with older CPUs in the family.  MPIR
supports some CPUs like this in both ABIs.  In fact within MPIR 'ABI'
means a combination of chip ABI, plus how MPIR chooses to use it.  For
example in some 32-bit ABIs, MPIR may support a limb as either a 32-bit
'long' or a 64-bit 'long long'.

   By default MPIR chooses the best ABI available for a given system,
and this generally gives significantly greater speed.  But an ABI can be
chosen explicitly to make MPIR compatible with other libraries, or
particular application requirements.  For example,

     ./configure ABI=32

   In all cases it's vital that all object code used in a given program
is compiled for the same ABI.

   Usually a limb is implemented as a 'long'.  When a 'long long' limb
is used this is encoded in the generated 'mpir.h'.  This is convenient
for applications, but it does mean that 'mpir.h' will vary, and can't be
just copied around.  'mpir.h' remains compiler independent though, since
all compilers for a particular ABI will be expected to use the same limb
type.

   Currently no attempt is made to follow whatever conventions a system
has for installing library or header files built for a particular ABI.
This will probably only matter when installing multiple builds of MPIR,
and it might be as simple as configuring with a special 'libdir', or it
might require more than that.  Note that builds for different ABIs need
to done separately, with a fresh ('make distclean'), './configure' and
'make'.


AMD64 ('x86_64')
     On AMD64 systems supporting both 32-bit and 64-bit modes for
     applications, the following ABI choices are available.

     'ABI=64'
          The 64-bit ABI uses 64-bit limbs and pointers and makes full
          use of the chip architecture.  This is the default.
          Applications will usually not need special compiler flags, but
          for reference the option is

               gcc  -m64

     'ABI=32'
          The 32-bit ABI is the usual i386 conventions.  This will be
          slower, and is not recommended except for inter-operating with
          other code not yet 64-bit capable.  Applications must be
          compiled with

               gcc  -m32

          (In GCC 2.95 and earlier there's no '-m32' option, it's the
          only mode.)


IA-64 under HP-UX ('ia64*-*-hpux*', 'itanium*-*-hpux*')
     HP-UX supports two ABIs for IA-64.  MPIR performance is the same in
     both.

     'ABI=32'
          In the 32-bit ABI, pointers, 'int's and 'long's are 32 bits
          and MPIR uses a 64 bit 'long long' for a limb.  Applications
          can be compiled without any special flags since this ABI is
          the default in both HP C and GCC, but for reference the flags
          are

               gcc  -milp32
               cc   +DD32

     'ABI=64'
          In the 64-bit ABI, 'long's and pointers are 64 bits and MPIR
          uses a 'long' for a limb.  Applications must be compiled with

               gcc  -mlp64
               cc   +DD64

     On other IA-64 systems, GNU/Linux for instance, 'ABI=64' is the
     only choice.


PowerPC 64 ('powerpc64', 'powerpc620', 'powerpc630', 'powerpc970')
     'ABI=aix64'
          The AIX 64 ABI uses 64-bit limbs and pointers and is the
          default on PowerPC 64 '*-*-aix*' systems.  Applications must
          be compiled with

               gcc  -maix64
               xlc  -q64

     'ABI=mode32'
          The 'mode32' ABI uses a 64-bit 'long long' limb but with the
          chip still in 32-bit mode and using 32-bit calling
          conventions.  This is the default on PowerPC 64 '*-*-darwin*'
          systems.  No special compiler options are needed for
          applications.

     'ABI=32'
          This is the basic 32-bit PowerPC ABI, with a 32-bit limb.  No
          special compiler options are needed for applications.

     MPIR speed is greatest in 'aix64' and 'mode32'.  In 'ABI=32' only
     the 32-bit ISA is used and this doesn't make full use of a 64-bit
     chip.  On a suitable system we could perhaps use more of the ISA,
     but there are no plans to do so.


Sparc V9 ('sparc64', 'sparcv9', 'ultrasparc*')
     'ABI=64'
          The 64-bit V9 ABI is available on the various BSD sparc64
          ports, recent versions of Sparc64 GNU/Linux, and Solaris 2.7
          and up (when the kernel is in 64-bit mode).  GCC 3.2 or
          higher, or Sun 'cc' is required.  On GNU/Linux, depending on
          the default 'gcc' mode, applications must be compiled with

               gcc  -m64

          On Solaris applications must be compiled with

               gcc  -m64 -mptr64 -Wa,-xarch=v9 -mcpu=v9
               cc   -xarch=v9

          On the BSD sparc64 systems no special options are required,
          since 64-bits is the only ABI available.

     'ABI=32'
          For the basic 32-bit ABI, MPIR still uses as much of the V9
          ISA as it can.  In the Sun documentation this combination is
          known as "v8plus".  On GNU/Linux, depending on the default
          'gcc' mode, applications may need to be compiled with

               gcc  -m32

          On Solaris, no special compiler options are required for
          applications, though using something like the following is
          recommended.  ('gcc' 2.8 and earlier only support '-mv8'
          though.)

               gcc  -mv8plus
               cc   -xarch=v8plus

     MPIR speed is greatest in 'ABI=64', so it's the default where
     available.  The speed is partly because there are extra registers
     available and partly because 64-bits is considered the more
     important case and has therefore had better code written for it.

     Don't be confused by the names of the '-m' and '-x' compiler
     options, they're called 'arch' but effectively control both ABI and
     ISA.

     On Solaris 2.6 and earlier, only 'ABI=32' is available since the
     kernel doesn't save all registers.

     On Solaris 2.7 with the kernel in 32-bit mode, a normal native
     build will reject 'ABI=64' because the resulting executables won't
     run.  'ABI=64' can still be built if desired by making it look like
     a cross-compile, for example

          ./configure --build=none --host=sparcv9-sun-solaris2.7 ABI=64


File: mpir.info,  Node: Notes for Package Builds,  Next: Building with Microsoft Visual Studio,  Prev: ABI and ISA,  Up: Installing MPIR

2.3 Notes for Package Builds
============================

MPIR should present no great difficulties for packaging in a binary
distribution.

   Libtool is used to build the library and '-version-info' is set
appropriately, having started from '3:0:0' in GMP 3.0 (*note Library
interface versions: (libtool)Versioning.).

   The GMP 4 series and MPIR 1 series will be upwardly binary compatible
in each release and will be upwardly binary compatible with all of the
GMP 3 series.  Additional function interfaces may be added in each
release, so on systems where libtool versioning is not fully checked by
the loader an auxiliary mechanism may be needed to express that a
dynamic linked application depends on a new enough MPIR.

   From MPIR 2.0.0 binary compatibility with the GMP 5 series will be
maintained with the exception of the availability of secure functions
for cryptography, which will not be supported in MPIR. For full GMP
compatibility, including deprecated functionality, the
'--enable-gmpcompat' configuration option must be used.

   An auxiliary mechanism may also be needed to express that
'libmpirxx.la' (from '--enable-cxx', *note Build Options::) requires
'libmpir.la' from the same MPIR version, since this is not done by the
libtool versioning, nor otherwise.  A mismatch will result in unresolved
symbols from the linker, or perhaps the loader.

   When building a package for a CPU family, care should be taken to use
'--host' (or '--build') to choose the least common denominator among the
CPUs which might use the package.  For example this might mean plain
'sparc' (meaning V7) for SPARCs.

   For x86s, '--enable-fat' sets things up for a fat binary build,
making a runtime selection of optimized low level routines.  This is a
good choice for packaging to run on a range of x86 chips.

   Users who care about speed will want MPIR built for their exact CPU
type, to make best use of the available optimizations.  Providing a way
to suitably rebuild a package may be useful.  This could be as simple as
making it possible for a user to omit '--build' (and '--host') so
'./config.guess' will detect the CPU.  But a way to manually specify a
'--build' will be wanted for systems where './config.guess' is inexact.

   On systems with multiple ABIs, a packaged build will need to decide
which among the choices is to be provided, see *note ABI and ISA::.  A
given run of './configure' etc will only build one ABI.  If a second ABI
is also required then a second run of './configure' etc must be made,
starting from a clean directory tree ('make distclean').

   As noted under "ABI and ISA", currently no attempt is made to follow
system conventions for install locations that vary with ABI, such as
'/usr/lib/sparcv9' for 'ABI=64' as opposed to '/usr/lib' for 'ABI=32'.
A package build can override 'libdir' and other standard variables as
necessary.

   Note that 'mpir.h' is a generated file, and will be architecture and
ABI dependent.  When attempting to install two ABIs simultaneously it
will be important that an application compile gets the correct 'mpir.h'
for its desired ABI.  If compiler include paths don't vary with ABI
options then it might be necessary to create a '/usr/include/mpir.h'
which tests preprocessor symbols and chooses the correct actual
'mpir.h'.


File: mpir.info,  Node: Building with Microsoft Visual Studio,  Next: Notes for Particular Systems,  Prev: Notes for Package Builds,  Up: Installing MPIR

2.4 Building with Microsoft Visual Studio
=========================================

MPIR can be built with the professional and higher versions of Visual
Studio 2012, 2013, 2015 and 2017.  It can also be built with the
community editions of Visual Studio 2015 and 2017.  If the assembler
optimised versions of MPIR are required, then both Python 3 and the YASM
assembler also need to be installed.  MPIR can also be built with the
Intel C/C++ compiler that can be integrated into versions of Visual
Studio.

   Python 3 can be obtained from:

     <https://www.python.org/>

   and the YASM assembler from:

     <http://yasm.tortall.net/Download.html>

   This assembler ('vsyasm.exe', NOT 'yasm.exe') should be placed in the
directory "C:\Program Files\yasm".

   Alternatively 'vsyasm.exe' can be placed elsewhere provided that the
environment variable 'YASMPATH' gives its location.

Building MPIR

     A build of MPIR is started by double clicking on the file
     'mpir.sln' in the appropriate sub-directory within the MPIR root
     directory:

              Visual Studio 2012:  mpir/build.vc11/mpir.sln
              Visual Studio 2013:  mpir/build.vc12/mpir.sln
              Visual Studio 2015:  mpir/build.vc14/mpir.sln
              Visual Studio 2017:  mpir/build.vc15/mpir.sln

     Visual Studio will then display a list of individual build projects
     from which an appropriate version of MPIR can be built.  For
     example, a typical list of projects is:

              dll_mpir_gc     standard DLL, no assembler (win32 and x64)
              dll_mpir_p3     assembly optimised DLL for pentium 3 (win32)
              lib_mpir_p3     assembly optimised static library for
                              pentium 3 (x64)
              lib_mpir_core2  assembly optimised static library for
                              core2 (x64)
              dll_mpir_core2  assembly optimised DLL for core2 (x64)

     MPIR can be built either as a static library or as a DLL. A DLL
     will include both the C and C++ features of MPIR but a static
     library will include only the C features so in this case the
     project:

            lib_mpir_cxx     the MPIRXX C++ static library (win32 and x64)

     should also be built to provide the MPIR C++ static library
     ('MPIRXX').

     Before a project is built, Visual Studio should be set to the
     required configuration (Release or Debug) and the required target
     architecture (win32 or x64).  The build process puts the output
     files into one of the two sub-directories:

          'mpir/lib'
          'mpir/dll'

     depending on whether static library or DLL versions have been
     built.

Additional Assembler Optimised Versions

     The Visual Studio builds for MPIR are initially provided with a
     small set of assembler optimised projects but many more are
     available and can be obtained by running the Python program
     'mpir_config.py <N>' that is in the mpir\build-vc directory.  The
     value of <N> required depends on the version of Visual Studio in
     use as follows:

              Visual Studio 2012:  11
              Visual Studio 2013:  12
              Visual Studio 2015:  14
              Visual Studio 2017:  15

     This program, which has to be run before Visual Studio, provides a
     list of all the assembler optimised versions of MPIR that are
     available.  Any number of versions can be chosen and these builds
     will then be available when Visual Studio is subsequently opened by
     double clicking on 'mpir.sln'.

Testing Visual Studio versions of MPIR

     Testing a version of the library once it has been built is started
     by double clicking on the appropriate solution file:

              Visual Studio 2012:  mpir/build.vc11/mpir-tests.sln
              Visual Studio 2013:  mpir/build.vc12/mpir-tests.sln
              Visual Studio 2015:  mpir/build.vc14/mpir-tests.sln
              Visual Studio 2017:  mpir/build.vc15/mpir-tests.sln

     The tests are always run on the last version of MPIR built and it
     is important that the configuration set for building the tests
     (Release or Debug, win32 or x64) is the same as that used to build
     MPIR. When testing the static library versions of MPIR, both the C
     (mpir.lib) and C++ (mpirxx.lib) must be built.  After loading there
     will be a large list of test projects starting:

            Solution `mpir-tests' (202 projects)
                  add-test-lib
                  bswap
                  constants
                  ....

     The project 'add-test-lib' should be selected and built first,
     after which the solution as a whole (i.e.  the first line shown
     above) can be selected to build all the tests.  After the build has
     completed, the tests are run by executing the Python program
     'run-tests.py' in the appropriate Visual Studio build
     sub-directory, for example, for Visual Studio 2017:

             mpir/build.vc15/mpir-tests/run-tests.py

Further Details

     Additional details can be found in the 'readme.txt' files in the
     appropriate Visual Studio build sub-directories.


File: mpir.info,  Node: Notes for Particular Systems,  Next: Known Build Problems,  Prev: Building with Microsoft Visual Studio,  Up: Installing MPIR

2.5 Notes for Particular Systems
================================

ARM
     On systems 'arm*-*-*', versions of GCC up to and including 2.95.3
     have a bug in unsigned division, giving wrong results for some
     operands.  MPIR './configure' will demand GCC 2.95.4 or later.

Floating Point Mode
     On some systems, the hardware floating point has a control mode
     which can set all operations to be done in a particular precision,
     for instance single, double or extended on x86 systems (x87
     floating point).  The MPIR functions involving a 'double' cannot be
     expected to operate to their full precision when the hardware is in
     single precision mode.  Of course this affects all code, including
     application code, not just MPIR.

MS-DOS and MS Windows
     On an MS Windows system Cygwin and Cygwin64 and Msys2/Mingw can be
     used, they are ports of GCC and the various GNU tools.

          <http://www.cygwin.com/>
          <https://msys2.github.io/>

     Both 32 and 64 bit versions of Msys2/Mingw and Cygwin are
     supported.  Building on these systems is very similar to building
     on Linux.

     We strongly recommend using recent versions of Cygwin/Msys2.

MS Windows DLLs
     On systems '*-*-cygwin*' and '*-*-mingw*' and '*-*-msys' static and
     DLL libraries can't both be built, since certain export directives
     in 'mpir.h' must be different.  Therefore you must specify whether
     you want a shared library or a static library.  For example if you
     want just a shared library you can type the following.

          ./configure --disable-static --enable-shared

     Libtool doesn't install a '.lib' format import library, but it can
     be created with MS 'lib' as follows, and copied to the install
     directory.  Similarly for 'libmpir' and 'libmpirxx'.

          cd .libs
          lib /def:libgmp-3.dll.def /out:libgmp-3.lib

Sparc CPU Types
     'sparcv8' or 'supersparc' on relevant systems will give a
     significant performance increase over the V7 code selected by plain
     'sparc'.

Sparc App Regs
     The MPIR assembler code for both 32-bit and 64-bit Sparc clobbers
     the "application registers" 'g2', 'g3' and 'g4', the same way that
     the GCC default '-mapp-regs' does (*note SPARC Options: (gcc)SPARC
     Options.).

     This makes that code unsuitable for use with the special V9
     '-mcmodel=embmedany' (which uses 'g4' as a data segment pointer),
     and for applications wanting to use those registers for special
     purposes.  In these cases the only suggestion currently is to build
     MPIR with CPU 'none' to avoid the assembler code.

SPARC Solaris
     Building applications against MPIR on SPARC Solaris (including
     'make check') requires the 'LD_LIBRARY_PATH' to be set
     appropriately.  In particular if one is building with 'ABI=64' the
     linker needs to know where to find 'libgcc' (often often
     '/usr/lib/sparcv9' or '/usr/local/lib/sparcv9' or '/lib/sparcv9').

     It is not enough to specify the location in 'LD_LIBRARY_PATH_64'
     unless 'LD_LIBRARY_PATH_64' is added to 'LD_LIBRARY_PATH'.
     Specifically the 64 bit 'libgcc' path needs to be in
     'LD_LIBRARY_PATH'.

     The linker is able to automatically distinguish 32 and 64 bit
     libraries, so it is safe to include paths to both the 32 and 64 bit
     libraries in the 'LD_LIBRARY_PATH'.

Solaris 10 First Release on SPARC
     MPIR fails to build with Solaris 10 first release.  Patch 123647-01
     for SPARC, released by Sun in August 2006 fixes this problem.

x86 CPU Types
     'i586', 'pentium' or 'pentiummmx' code is good for its intended P5
     Pentium chips, but quite slow when run on Intel P6 class chips
     (PPro, P-II, P-III).  'i386' is a better choice when making
     binaries that must run on both.

x86 MMX and SSE2 Code
     If the CPU selected has MMX code but the assembler doesn't support
     it, a warning is given and non-MMX code is used instead.  This will
     be an inferior build, since the MMX code that's present is there
     because it's faster than the corresponding plain integer code.  The
     same applies to SSE2.

     Old versions of 'gas' don't support MMX instructions, in particular
     version 1.92.3 that comes with FreeBSD 2.2.8 or the more recent
     OpenBSD 3.1 doesn't.

     Solaris 2.6 and 2.7 'as' generate incorrect object code for
     register to register 'movq' instructions, and so can't be used for
     MMX code.  Install a recent 'gas' if MMX code is wanted on these
     systems.


File: mpir.info,  Node: Known Build Problems,  Next: Performance optimization,  Prev: Notes for Particular Systems,  Up: Installing MPIR

2.6 Known Build Problems
========================

You might find more up-to-date information at <http://www.mpir.org/>.

GCC XOP issues
     GCC from version 4.6.0 to 4.8.x have a problem with the XOP
     instruction, especially with '-O3' on at least AMD Opteron
     '62xx/63xx', 'FX-(4,6,8)[13]xx' and the Devil's Canyon '9xxx' and
     the Kaveri APUs.

     A workaround is to pass '-mno-xop' when compiling with '-O3'.


File: mpir.info,  Node: Performance optimization,  Prev: Known Build Problems,  Up: Installing MPIR

2.7 Performance optimization
============================

For optimal performance, build MPIR for the exact CPU type of the target
computer, see *note Build Options::.

   Unlike what is the case for most other programs, the compiler
typically doesn't matter much, since MPIR uses assembly language for the
most critical operations.

   In particular for long-running MPIR applications, and applications
demanding extremely large numbers, building and running the 'tuneup'
program in the 'tune' subdirectory, can be important.  For example,

     cd tune
     make tuneup
     ./tuneup

   will generate better contents for the 'gmp-mparam.h' parameter file.

   To use the results, put the output in the file indicated in the
'Parameters for ...' header.  Then recompile from scratch.

   The 'tuneup' program takes one useful parameter, '-f NNN', which
instructs the program how long to check FFT multiply parameters.  If
you're going to use MPIR for extremely large numbers, you may want to
run 'tuneup' with a large NNN value.


File: mpir.info,  Node: MPIR Basics,  Next: Reporting Bugs,  Prev: Installing MPIR,  Up: Top

3 MPIR Basics
*************

*Using functions, macros, data types, etc. not documented in this manual
is strongly discouraged.  If you do so your application is guaranteed to
be incompatible with future versions of MPIR.*

* Menu:

* Headers and Libraries::
* Nomenclature and Types::
* MPIR on Windows x64::
* Function Classes::
* Variable Conventions::
* Parameter Conventions::
* Memory Management::
* Reentrancy::
* Useful Macros and Constants::
* Compatibility with older versions::
* Efficiency::
* Debugging::
* Profiling::
* Autoconf::
* Emacs::


File: mpir.info,  Node: Headers and Libraries,  Next: Nomenclature and Types,  Prev: MPIR Basics,  Up: MPIR Basics

3.1 Headers and Libraries
=========================

All declarations needed to use MPIR are collected in the include file
'mpir.h'.  It is designed to work with both C and C++ compilers.

     #include <mpir.h>

   Note however that prototypes for MPIR functions with 'FILE *'
parameters are only provided if '<stdio.h>' is included too.

     #include <stdio.h>
     #include <mpir.h>

   Likewise '<stdarg.h>' (or '<varargs.h>') is required for prototypes
with 'va_list' parameters, such as 'gmp_vprintf'.  And '<obstack.h>' for
prototypes with 'struct obstack' parameters, such as
'gmp_obstack_printf', when available.

   All programs using MPIR must link against the 'libmpir' library.  On
a typical Unix-like system this can be done with '-lmpir' respectively,
for example

     gcc myprogram.c -lmpir

   MPIR C++ functions are in a separate 'libmpirxx' library.  This is
built and installed if C++ support has been enabled (*note Build
Options::).  For example,

     g++ mycxxprog.cc -lmpirxx -lmpir

   MPIR is built using Libtool and an application can use that to link
if desired, *note GNU Libtool: (libtool)Top.

   If MPIR has been installed to a non-standard location then it may be
necessary to use '-I' and '-L' compiler options to point to the right
directories, and some sort of run-time path for a shared library.


File: mpir.info,  Node: Nomenclature and Types,  Next: MPIR on Windows x64,  Prev: Headers and Libraries,  Up: MPIR Basics

3.2 Nomenclature and Types
==========================

In this manual, "integer" usually means a multiple precision integer, as
defined by the MPIR library.  The C data type for such integers is
'mpz_t'.  Here are some examples of how to declare such integers:

     mpz_t sum;

     struct foo { mpz_t x, y; };

     mpz_t vec[20];

   "Rational number" means a multiple precision fraction.  The C data
type for these fractions is 'mpq_t'.  For example:

     mpq_t quotient;

   "Floating point number" or "Float" for short, is an arbitrary
precision mantissa with a limited precision exponent.  The C data type
for such objects is 'mpf_t'.  For example:

     mpf_t fp;

   The floating point functions accept and return exponents in the C
type 'mp_exp_t'.  Currently this is usually a 'long', but on some
systems it's an 'int' for efficiency.

   A "limb" means the part of a multi-precision number that fits in a
single machine word.  (We chose this word because a limb of the human
body is analogous to a digit, only larger, and containing several
digits.)  Normally a limb is 32 or 64 bits.  The C data type for a limb
is 'mp_limb_t'.

   Counts of limbs are represented in the C type 'mp_size_t'.  Currently
this is normally a 'long', but on some systems it's an 'int' for
efficiency.

   Counts of bits of a multi-precision number are represented in the C
type 'mp_bitcnt_t'.  Currently this is always an 'unsigned long', but on
some systems it will be an 'unsigned long long' in the future .

   "Random state" means an algorithm selection and current state data.
The C data type for such objects is 'gmp_randstate_t'.  For example:

     gmp_randstate_t rstate;

   Also, in general 'mp_bitcnt_t' is used for bit counts and ranges, and
'size_t' is used for byte or character counts.


File: mpir.info,  Node: MPIR on Windows x64,  Next: Function Classes,  Prev: Nomenclature and Types,  Up: MPIR Basics

3.3 MPIR on Windows x64
=======================

Although Windows x64 is a 64-bit operating system, Microsoft has decided
to make long integers 32-bits, which is inconsistent when compared with
almost all other 64-bit operating systems.  This has caused many subtle
bugs when open source code is ported to Windows x64 because many
developers reasonably expect to find that long integers on a 64-bit
operating system will be 64 bits long.

   MPIR contains functions with suffixes of '_ui' and '_si' that are
used to input unsigned and signed integers into and convert them for use
with MPIR's multiple precision integers (mpz types).  For example, the
following functions set an 'mpz_t' integer from 'unsigned' and 'signed
long' integers respectively.

 -- Function: void mpz_set_ui (mpz_t, unsigned long int)

 -- Function: void mpz_set_si (mpz_t, signed long int)


   Also, the following functions obtain 'unsigned' and 'signed long int'
values from an MPIR multiple precision integer ('mpz_t').

 -- Function: unsigned long int mpz_get_ui (mpz_t)

 -- Function: signed long int mpz_get_si (mpz_t)


   To bring MPIR on Windows x64 into line with other 64-bit operating
systems two new types have been introduced throughout MPIR:

   * 'mpir_ui' defined as 'unsigned long int' on all but Windows x64,
     defined as 'unsigned long long int' on Windows x64

   * 'mpir_si' defined as 'signed long int' on all but Windows x64,
     defined as 'signed long long int' on Windows x64


   The above prototypes in MPIR 2.6.0 are changed to:

 -- Function: void mpz_set_ui (mpz_t, mpir_ui)

 -- Function: void mpz_set_si (mpz_t, mpir_si)

 -- Function: mpir_ui mpz_get_ui (mpz_t)

 -- Function: mpir_si mpz_get_si (mpz_t)


   These changes are applied to all MPIR functions with '_ui' and '_si'
suffixes.


File: mpir.info,  Node: Function Classes,  Next: Variable Conventions,  Prev: MPIR on Windows x64,  Up: MPIR Basics

3.4 Function Classes
====================

There are five classes of functions in the MPIR library:

  1. Functions for signed integer arithmetic, with names beginning with
     'mpz_'.  The associated type is 'mpz_t'.  There are about 150
     functions in this class.  (*note Integer Functions::)

  2. Functions for rational number arithmetic, with names beginning with
     'mpq_'.  The associated type is 'mpq_t'.  There are about 40
     functions in this class, but the integer functions can be used for
     arithmetic on the numerator and denominator separately.  (*note
     Rational Number Functions::)

  3. Functions for floating-point arithmetic, with names beginning with
     'mpf_'.  The associated type is 'mpf_t'.  There are about 60
     functions is this class.  (*note Floating-point Functions::)

  4. Fast low-level functions that operate on natural numbers.  These
     are used by the functions in the preceding groups, and you can also
     call them directly from very time-critical user programs.  These
     functions' names begin with 'mpn_'.  The associated type is array
     of 'mp_limb_t'.  There are about 30 (hard-to-use) functions in this
     class.  (*note Low-level Functions::)

  5. Miscellaneous functions.  Functions for setting up custom
     allocation and functions for generating random numbers.  (*note
     Custom Allocation::, and *note Random Number Functions::)


File: mpir.info,  Node: Variable Conventions,  Next: Parameter Conventions,  Prev: Function Classes,  Up: MPIR Basics

3.5 Variable Conventions
========================

MPIR functions generally have output arguments before input arguments.
This notation is by analogy with the assignment operator.

   MPIR lets you use the same variable for both input and output in one
call.  For example, the main function for integer multiplication,
'mpz_mul', can be used to square 'x' and put the result back in 'x' with

     mpz_mul (x, x, x);

   Before you can assign to an MPIR variable, you need to initialize it
by calling one of the special initialization functions.  When you're
done with a variable, you need to clear it out, using one of the
functions for that purpose.  Which function to use depends on the type
of variable.  See the chapters on integer functions, rational number
functions, and floating-point functions for details.

   A variable should only be initialized once, or at least cleared
between each initialization.  After a variable has been initialized, it
may be assigned to any number of times.

   For efficiency reasons, avoid excessive initializing and clearing.
In general, initialize near the start of a function and clear near the
end.  For example,

     void
     foo (void)
     {
       mpz_t  n;
       int    i;
       mpz_init (n);
       for (i = 1; i < 100; i++)
         {
           mpz_mul (n, ...);
           mpz_fdiv_q (n, ...);
           ...
         }
       mpz_clear (n);
     }


File: mpir.info,  Node: Parameter Conventions,  Next: Memory Management,  Prev: Variable Conventions,  Up: MPIR Basics

3.6 Parameter Conventions
=========================

When an MPIR variable is used as a function parameter, it's effectively
a call-by-reference, meaning if the function stores a value there it
will change the original in the caller.  Parameters which are input-only
can be designated 'const' to provoke a compiler error or warning on
attempting to modify them.

   When a function is going to return an MPIR result, it should
designate a parameter that it sets, like the library functions do.  More
than one value can be returned by having more than one output parameter,
again like the library functions.  A 'return' of an 'mpz_t' etc doesn't
return the object, only a pointer, and this is almost certainly not
what's wanted.

   Here's an example accepting an 'mpz_t' parameter, doing a
calculation, and storing the result to the indicated parameter.

     void
     foo (mpz_t result, const mpz_t param, mpir_ui n)
     {
       mpir_ui  i;
       mpz_mul_ui (result, param, n);
       for (i = 1; i < n; i++)
         mpz_add_ui (result, result, i*7);
     }

     int
     main (void)
     {
       mpz_t  r, n;
       mpz_init (r);
       mpz_init_set_str (n, "123456", 0);
       foo (r, n, 20L);
       gmp_printf ("%Zd\n", r);
       return 0;
     }

   'foo' works even if the mainline passes the same variable for 'param'
and 'result', just like the library functions.  But sometimes it's
tricky to make that work, and an application might not want to bother
supporting that sort of thing.

   For interest, the MPIR types 'mpz_t' etc are implemented as
one-element arrays of certain structures.  This is why declaring a
variable creates an object with the fields MPIR needs, but then using it
as a parameter passes a pointer to the object.  Note that the actual
fields in each 'mpz_t' etc are for internal use only and should not be
accessed directly by code that expects to be compatible with future MPIR
releases.


File: mpir.info,  Node: Memory Management,  Next: Reentrancy,  Prev: Parameter Conventions,  Up: MPIR Basics

3.7 Memory Management
=====================

The MPIR types like 'mpz_t' are small, containing only a couple of
sizes, and pointers to allocated data.  Once a variable is initialized,
MPIR takes care of all space allocation.  Additional space is allocated
whenever a variable doesn't have enough.

   'mpz_t' and 'mpq_t' variables never reduce their allocated space.
Normally this is the best policy, since it avoids frequent reallocation.
Applications that need to return memory to the heap at some particular
point can use 'mpz_realloc2', or clear variables no longer needed.

   'mpf_t' variables, in the current implementation, use a fixed amount
of space, determined by the chosen precision and allocated at
initialization, so their size doesn't change.

   All memory is allocated using 'malloc' and friends by default, but
this can be changed, see *note Custom Allocation::.  Temporary memory on
the stack is also used (via 'alloca'), but this can be changed at
build-time if desired, see *note Build Options::.


File: mpir.info,  Node: Reentrancy,  Next: Useful Macros and Constants,  Prev: Memory Management,  Up: MPIR Basics

3.8 Reentrancy
==============

MPIR is reentrant and thread-safe, with some exceptions:

   * If configured with '--enable-alloca=malloc-notreentrant' (or with
     '--enable-alloca=notreentrant' when 'alloca' is not available),
     then naturally MPIR is not reentrant.

   * 'mpf_set_default_prec' and 'mpf_init' use a global variable for the
     selected precision.  'mpf_init2' can be used instead, and in the
     C++ interface an explicit precision to the 'mpf_class' constructor.

   * 'mp_set_memory_functions' uses global variables to store the
     selected memory allocation functions.

   * If the memory allocation functions set by a call to
     'mp_set_memory_functions' (or 'malloc' and friends by default) are
     not reentrant, then MPIR will not be reentrant either.

   * If the standard I/O functions such as 'fwrite' are not reentrant
     then the MPIR I/O functions using them will not be reentrant
     either.

   * It's safe for two threads to read from the same MPIR variable
     simultaneously, but it's not safe for one to read while the another
     might be writing, nor for two threads to write simultaneously.
     It's not safe for two threads to generate a random number from the
     same 'gmp_randstate_t' simultaneously, since this involves an
     update of that variable.


File: mpir.info,  Node: Useful Macros and Constants,  Next: Compatibility with older versions,  Prev: Reentrancy,  Up: MPIR Basics

3.9 Useful Macros and Constants
===============================

 -- Global Constant: const int mp_bits_per_limb
     The number of bits per limb.

 -- Macro: __GNU_MP_VERSION
 -- Macro: __GNU_MP_VERSION_MINOR
 -- Macro: __GNU_MP_VERSION_PATCHLEVEL
     The major and minor GMP version, and patch level, respectively, as
     integers.  For GMP i.j.k, these numbers will be i, j, and k,
     respectively.  These numbers represent the version of GMP fully
     supported by this version of MPIR.

 -- Macro: __MPIR_VERSION
 -- Macro: __MPIR_VERSION_MINOR
 -- Macro: __MPIR_VERSION_PATCHLEVEL
     The major and minor MPIR version, and patch level, respectively, as
     integers.  For MPIR i.j.k, these numbers will be i, j, and k,
     respectively.

 -- Global Constant: const char * const gmp_version
     The GNU MP version number, as a null-terminated string, in the form
     "i.j.k".

 -- Macro: __GMP_CC
 -- Macro: __GMP_CFLAGS
     The compiler and compiler flags, respectively, used when compiling
     GMP, as strings.

 -- Global Constant: const char * const mpir_version
     The MPIR version number, as a null-terminated string, in the form
     "i.j.k".  This release is "3.0.0".


File: mpir.info,  Node: Compatibility with older versions,  Next: Efficiency,  Prev: Useful Macros and Constants,  Up: MPIR Basics

3.10 Compatibility with older versions
======================================

This version of MPIR is upwardly binary compatible with all GMP 5.x, 4.x
and 3.x versions, and upwardly compatible at the source level with all
2.x versions, with the following exceptions.

   * 'mpn_gcd' had its source arguments swapped as of GMP 3.0, for
     consistency with other 'mpn' functions.

   * 'mpf_get_prec' counted precision slightly differently in GMP 3.0
     and 3.0.1, but in 3.1 reverted to the 2.x style.

   * 'mpn_bdivmod' provided provisionally in the past has been removed
     from MPIR 2.7.0.

   * MPIR does not support the secure cryptographic functions provided
     by GMP.

   * Full GMP compatibility is only available when the
     '--enable-gmpcompat' configure option is used.

   There are a number of compatibility issues between GMP 1 and GMP 2
that of course also apply when porting applications from GMP 1 to GMP 4
and MPIR 1 and 2.  Please see the GMP 2 manual for details.


File: mpir.info,  Node: Efficiency,  Next: Debugging,  Prev: Compatibility with older versions,  Up: MPIR Basics

3.11 Efficiency
===============

Small Operands
     On small operands, the time for function call overheads and memory
     allocation can be significant in comparison to actual calculation.
     This is unavoidable in a general purpose variable precision
     library, although MPIR attempts to be as efficient as it can on
     both large and small operands.

Static Linking
     On some CPUs, in particular the x86s, the static 'libmpir.a' should
     be used for maximum speed, since the PIC code in the shared
     'libmpir.so' will have a small overhead on each function call and
     global data address.  For many programs this will be insignificant,
     but for long calculations there's a gain to be had.

Initializing and Clearing
     Avoid excessive initializing and clearing of variables, since this
     can be quite time consuming, especially in comparison to otherwise
     fast operations like addition.

     A language interpreter might want to keep a free list or stack of
     initialized variables ready for use.  It should be possible to
     integrate something like that with a garbage collector too.

Reallocations
     An 'mpz_t' or 'mpq_t' variable used to hold successively increasing
     values will have its memory repeatedly 'realloc'ed, which could be
     quite slow or could fragment memory, depending on the C library.
     If an application can estimate the final size then 'mpz_init2' or
     'mpz_realloc2' can be called to allocate the necessary space from
     the beginning (*note Initializing Integers::).

     It doesn't matter if a size set with 'mpz_init2' or 'mpz_realloc2'
     is too small, since all functions will do a further reallocation if
     necessary.  Badly overestimating memory required will waste space
     though.

'2exp' Functions
     It's up to an application to call functions like 'mpz_mul_2exp'
     when appropriate.  General purpose functions like 'mpz_mul' make no
     attempt to identify powers of two or other special forms, because
     such inputs will usually be very rare and testing every time would
     be wasteful.

'ui' and 'si' Functions
     The 'ui' functions and the small number of 'si' functions exist for
     convenience and should be used where applicable.  But if for
     example an 'mpz_t' contains a value that fits in an 'unsigned long'
     ('unsigned long long' on Windows x64) there's no need extract it
     and call a 'ui' function, just use the regular 'mpz' function.

In-Place Operations
     'mpz_abs', 'mpq_abs', 'mpf_abs', 'mpz_neg', 'mpq_neg' and 'mpf_neg'
     are fast when used for in-place operations like 'mpz_abs(x,x)',
     since in the current implementation only a single field of 'x'
     needs changing.  On suitable compilers (GCC for instance) this is
     inlined too.

     'mpz_add_ui', 'mpz_sub_ui', 'mpf_add_ui' and 'mpf_sub_ui' benefit
     from an in-place operation like 'mpz_add_ui(x,x,y)', since usually
     only one or two limbs of 'x' will need to be changed.  The same
     applies to the full precision 'mpz_add' etc if 'y' is small.  If
     'y' is big then cache locality may be helped, but that's all.

     'mpz_mul' is currently the opposite, a separate destination is
     slightly better.  A call like 'mpz_mul(x,x,y)' will, unless 'y' is
     only one limb, make a temporary copy of 'x' before forming the
     result.  Normally that copying will only be a tiny fraction of the
     time for the multiply, so this is not a particularly important
     consideration.

     'mpz_set', 'mpq_set', 'mpq_set_num', 'mpf_set', etc, make no
     attempt to recognise a copy of something to itself, so a call like
     'mpz_set(x,x)' will be wasteful.  Naturally that would never be
     written deliberately, but if it might arise from two pointers to
     the same object then a test to avoid it might be desirable.

          if (x != y)
            mpz_set (x, y);

     Note that it's never worth introducing extra 'mpz_set' calls just
     to get in-place operations.  If a result should go to a particular
     variable then just direct it there and let MPIR take care of data
     movement.

Divisibility Testing (Small Integers)
     'mpz_divisible_ui_p' and 'mpz_congruent_ui_p' are the best
     functions for testing whether an 'mpz_t' is divisible by an
     individual small integer.  They use an algorithm which is faster
     than 'mpz_tdiv_ui', but which gives no useful information about the
     actual remainder, only whether it's zero (or a particular value).

     However when testing divisibility by several small integers, it's
     best to take a remainder modulo their product, to save
     multi-precision operations.  For instance to test whether a number
     is divisible by any of 23, 29 or 31 take a remainder modulo
     23*29*31 = 20677 and then test that.

     The division functions like 'mpz_tdiv_q_ui' which give a quotient
     as well as a remainder are generally a little slower than the
     remainder-only functions like 'mpz_tdiv_ui'.  If the quotient is
     only rarely wanted then it's probably best to just take a remainder
     and then go back and calculate the quotient if and when it's wanted
     ('mpz_divexact_ui' can be used if the remainder is zero).

Rational Arithmetic
     The 'mpq' functions operate on 'mpq_t' values with no common
     factors in the numerator and denominator.  Common factors are
     checked-for and cast out as necessary.  In general, cancelling
     factors every time is the best approach since it minimizes the
     sizes for subsequent operations.

     However, applications that know something about the factorization
     of the values they're working with might be able to avoid some of
     the GCDs used for canonicalization, or swap them for divisions.
     For example when multiplying by a prime it's enough to check for
     factors of it in the denominator instead of doing a full GCD.  Or
     when forming a big product it might be known that very little
     cancellation will be possible, and so canonicalization can be left
     to the end.

     The 'mpq_numref' and 'mpq_denref' macros give access to the
     numerator and denominator to do things outside the scope of the
     supplied 'mpq' functions.  *Note Applying Integer Functions::.

     The canonical form for rationals allows mixed-type 'mpq_t' and
     integer additions or subtractions to be done directly with
     multiples of the denominator.  This will be somewhat faster than
     'mpq_add'.  For example,

          /* mpq increment */
          mpz_add (mpq_numref(q), mpq_numref(q), mpq_denref(q));

          /* mpq += unsigned long */
          mpz_addmul_ui (mpq_numref(q), mpq_denref(q), 123UL);

          /* mpq -= mpz */
          mpz_submul (mpq_numref(q), mpq_denref(q), z);

Number Sequences
     Functions like 'mpz_fac_ui', 'mpz_fib_ui' and 'mpz_bin_uiui' are
     designed for calculating isolated values.  If a range of values is
     wanted it's probably best to call to get a starting point and
     iterate from there.

Text Input/Output
     Hexadecimal or octal are suggested for input or output in text
     form.  Power-of-2 bases like these can be converted much more
     efficiently than other bases, like decimal.  For big numbers
     there's usually nothing of particular interest to be seen in the
     digits, so the base doesn't matter much.

     Maybe we can hope octal will one day become the normal base for
     everyday use, as proposed by King Charles XII of Sweden and later
     reformers.


File: mpir.info,  Node: Debugging,  Next: Profiling,  Prev: Efficiency,  Up: MPIR Basics

3.12 Debugging
==============

Stack Overflow
     Depending on the system, a segmentation violation or bus error
     might be the only indication of stack overflow.  See
     '--enable-alloca' choices in *note Build Options::, for how to
     address this.

     In new enough versions of GCC, '-fstack-check' may be able to
     ensure an overflow is recognised by the system before too much
     damage is done, or '-fstack-limit-symbol' or
     '-fstack-limit-register' may be able to add checking if the system
     itself doesn't do any (*note Options for Code Generation: (gcc)Code
     Gen Options.).  These options must be added to the 'CFLAGS' used in
     the MPIR build (*note Build Options::), adding them just to an
     application will have no effect.  Note also they're a slowdown,
     adding overhead to each function call and each stack allocation.

Heap Problems
     The most likely cause of application problems with MPIR is heap
     corruption.  Failing to 'init' MPIR variables will have
     unpredictable effects, and corruption arising elsewhere in a
     program may well affect MPIR.  Initializing MPIR variables more
     than once or failing to clear them will cause memory leaks.

     In all such cases a 'malloc' debugger is recommended.  On a GNU or
     BSD system the standard C library 'malloc' has some diagnostic
     facilities, see *note Allocation Debugging: (libc)Allocation
     Debugging, or 'man 3 malloc'.  Other possibilities, in no
     particular order, include

          <http://dmalloc.com/>
          <http://www.perens.com/FreeSoftware/>  (electric fence)
          <http://www.gnupdate.org/components/leakbug/>
          <http://wwww.gnome.org/projects/memprof>

     The MPIR default allocation routines in 'memory.c' also have a
     simple sentinel scheme which can be enabled with '#define DEBUG' in
     that file.  This is mainly designed for detecting buffer overruns
     during MPIR development, but might find other uses.

Stack Backtraces
     On some systems the compiler options MPIR uses by default can
     interfere with debugging.  In particular on x86 and 68k systems
     '-fomit-frame-pointer' is used and this generally inhibits stack
     backtracing.  Recompiling without such options may help while
     debugging, though the usual caveats about it potentially moving a
     memory problem or hiding a compiler bug will apply.

GDB, the GNU Debugger
     A sample '.gdbinit' is included in the distribution, showing how to
     call some undocumented dump functions to print MPIR variables from
     within GDB.  Note that these functions shouldn't be used in final
     application code since they're undocumented and may be subject to
     incompatible changes in future versions of MPIR.

Source File Paths
     MPIR has multiple source files with the same name, in different
     directories.  For example 'mpz', 'mpq' and 'mpf' each have an
     'init.c'.  If the debugger can't already determine the right one it
     may help to build with absolute paths on each C file.  One way to
     do that is to use a separate object directory with an absolute path
     to the source directory.

          cd /my/build/dir
          /my/source/dir/gmp-3.0.0/configure

     This works via 'VPATH', and might require GNU 'make'.  Alternately
     it might be possible to change the '.c.lo' rules appropriately.

Assertion Checking
     The build option '--enable-assert' is available to add some
     consistency checks to the library (see *note Build Options::).
     These are likely to be of limited value to most applications.
     Assertion failures are just as likely to indicate memory corruption
     as a library or compiler bug.

     Applications using the low-level 'mpn' functions, however, will
     benefit from '--enable-assert' since it adds checks on the
     parameters of most such functions, many of which have subtle
     restrictions on their usage.  Note however that only the generic C
     code has checks, not the assembler code, so CPU 'none' should be
     used for maximum checking.

Temporary Memory Checking
     The build option '--enable-alloca=debug' arranges that each block
     of temporary memory in MPIR is allocated with a separate call to
     'malloc' (or the allocation function set with
     'mp_set_memory_functions').

     This can help a malloc debugger detect accesses outside the
     intended bounds, or detect memory not released.  In a normal build,
     on the other hand, temporary memory is allocated in blocks which
     MPIR divides up for its own use, or may be allocated with a
     compiler builtin 'alloca' which will go nowhere near any malloc
     debugger hooks.

Maximum Debuggability
     To summarize the above, an MPIR build for maximum debuggability
     would be

          ./configure --disable-shared --enable-assert \
            --enable-alloca=debug --host=none CFLAGS=-g

     For C++, add '--enable-cxx CXXFLAGS=-g'.

Checker
     The GCC checker (<http://savannah.gnu.org/projects/checker/>) can
     be used with MPIR.  It contains a stub library which means MPIR
     applications compiled with checker can use a normal MPIR build.

     A build of MPIR with checking within MPIR itself can be made.  This
     will run very very slowly.  On GNU/Linux for example,

          ./configure --host=none-pc-linux-gnu CC=checkergcc

     '--host=none' must be used, since the MPIR assembler code doesn't
     support the checking scheme.  The MPIR C++ features cannot be used,
     since current versions of checker (0.9.9.1) don't yet support the
     standard C++ library.

Valgrind
     The valgrind program (<http://valgrind.org/>) is a memory checker
     for x86s.  It translates and emulates machine instructions to do
     strong checks for uninitialized data (at the level of individual
     bits), memory accesses through bad pointers, and memory leaks.

     Recent versions of Valgrind are getting support for MMX and
     SSE/SSE2 instructions, for past versions MPIR will need to be
     configured not to use those, ie. for an x86 without them (for
     instance plain 'i486').

Other Problems
     Any suspected bug in MPIR itself should be isolated to make sure
     it's not an application problem, see *note Reporting Bugs::.


File: mpir.info,  Node: Profiling,  Next: Autoconf,  Prev: Debugging,  Up: MPIR Basics

3.13 Profiling
==============

Running a program under a profiler is a good way to find where it's
spending most time and where improvements can be best sought.  The
profiling choices for a MPIR build are as follows.

'--disable-profiling'
     The default is to add nothing special for profiling.

     It should be possible to just compile the mainline of a program
     with '-p' and use 'prof' to get a profile consisting of timer-based
     sampling of the program counter.  Most of the MPIR assembler code
     has the necessary symbol information.

     This approach has the advantage of minimizing interference with
     normal program operation, but on most systems the resolution of the
     sampling is quite low (10 milliseconds for instance), requiring
     long runs to get accurate information.

'--enable-profiling=prof'
     Build with support for the system 'prof', which means '-p' added to
     the 'CFLAGS'.

     This provides call counting in addition to program counter
     sampling, which allows the most frequently called routines to be
     identified, and an average time spent in each routine to be
     determined.

     The x86 assembler code has support for this option, but on other
     processors the assembler routines will be as if compiled without
     '-p' and therefore won't appear in the call counts.

     On some systems, such as GNU/Linux, '-p' in fact means '-pg' and in
     this case '--enable-profiling=gprof' described below should be used
     instead.

'--enable-profiling=gprof'
     Build with support for 'gprof' (*note GNU gprof: (gprof)Top.),
     which means '-pg' added to the 'CFLAGS'.

     This provides call graph construction in addition to call counting
     and program counter sampling, which makes it possible to count
     calls coming from different locations.  For example the number of
     calls to 'mpn_mul' from 'mpz_mul' versus the number from 'mpf_mul'.
     The program counter sampling is still flat though, so only a total
     time in 'mpn_mul' would be accumulated, not a separate amount for
     each call site.

     The x86 assembler code has support for this option, but on other
     processors the assembler routines will be as if compiled without
     '-pg' and therefore not be included in the call counts.

     On x86 and m68k systems '-pg' and '-fomit-frame-pointer' are
     incompatible, so the latter is omitted from the default flags in
     that case, which might result in poorer code generation.

     Incidentally, it should be possible to use the 'gprof' program with
     a plain '--enable-profiling=prof' build.  But in that case only the
     'gprof -p' flat profile and call counts can be expected to be
     valid, not the 'gprof -q' call graph.

'--enable-profiling=instrument'
     Build with the GCC option '-finstrument-functions' added to the
     'CFLAGS' (*note Options for Code Generation: (gcc)Code Gen
     Options.).

     This inserts special instrumenting calls at the start and end of
     each function, allowing exact timing and full call graph
     construction.

     This instrumenting is not normally a standard system feature and
     will require support from an external library, such as

          <http://sourceforge.net/projects/fnccheck/>

     This should be included in 'LIBS' during the MPIR configure so that
     test programs will link.  For example,

          ./configure --enable-profiling=instrument LIBS=-lfc

     On a GNU system the C library provides dummy instrumenting
     functions, so programs compiled with this option will link.  In
     this case it's only necessary to ensure the correct library is
     added when linking an application.

     The x86 assembler code supports this option, but on other
     processors the assembler routines will be as if compiled without
     '-finstrument-functions' meaning time spent in them will
     effectively be attributed to their caller.


File: mpir.info,  Node: Autoconf,  Next: Emacs,  Prev: Profiling,  Up: MPIR Basics

3.14 Autoconf
=============

Autoconf based applications can easily check whether MPIR is installed.
The only thing to be noted is that GMP/MPIR library symbols from version
3 of GMP and version 1 of MPIR onwards have prefixes like '__gmpz'.  The
following therefore would be a simple test,

     AC_CHECK_LIB(mpir, __gmpz_init)

   This just uses the default 'AC_CHECK_LIB' actions for found or not
found, but an application that must have MPIR would want to generate an
error if not found.  For example,

     AC_CHECK_LIB(mpir, __gmpz_init, ,
       [AC_MSG_ERROR([MPIR not found, see http://www.mpir.org/])])

   If functions added in some particular version of GMP/MPIR are
required, then one of those can be used when checking.  For example
'mpz_mul_si' was added in GMP 3.1,

     AC_CHECK_LIB(mpir, __gmpz_mul_si, ,
       [AC_MSG_ERROR(
       [GMP/MPIR not found, or not GMP 3.1 or up or MPIR 1.0 or up, see http://www.mpir.org/])])

   An alternative would be to test the version number in 'mpir.h' using
say 'AC_EGREP_CPP'.  That would make it possible to test the exact
version, if some particular sub-minor release is known to be necessary.

   In general it's recommended that applications should simply demand a
new enough MPIR rather than trying to provide supplements for features
not available in past versions.

   Occasionally an application will need or want to know the size of a
type at configuration or preprocessing time, not just with 'sizeof' in
the code.  This can be done in the normal way with 'mp_limb_t' etc, but
GMP 4.0 or up and MPIR 1.0 and up is best for this, since prior versions
needed certain '-D' defines on systems using a 'long long' limb.  The
following would suit Autoconf 2.50 or up,

     AC_CHECK_SIZEOF(mp_limb_t, , [#include <mpir.h>])


File: mpir.info,  Node: Emacs,  Prev: Autoconf,  Up: MPIR Basics

3.15 Emacs
==========

<C-h C-i> ('info-lookup-symbol') is a good way to find documentation on
C functions while editing (*note Info Documentation Lookup: (emacs)Info
Lookup.).

   The MPIR manual can be included in such lookups by putting the
following in your '.emacs',

     (eval-after-load "info-look"
       '(let ((mode-value (assoc 'c-mode (assoc 'symbol info-lookup-alist))))
          (setcar (nthcdr 3 mode-value)
                  (cons '("(gmp)Function Index" nil "^ -.* " "\\>")
                        (nth 3 mode-value)))))


File: mpir.info,  Node: Reporting Bugs,  Next: Integer Functions,  Prev: MPIR Basics,  Up: Top

4 Reporting Bugs
****************

If you think you have found a bug in the MPIR library, please
investigate it and report it.  We have made this library available to
you, and it is not too much to ask you to report the bugs you find.

   Before you report a bug, check it's not already addressed in *note
Known Build Problems::, or perhaps *note Notes for Particular Systems::.
You may also want to check <http://www.mpir.org/> for patches for this
release.

   Please include the following in any report,

   * The MPIR version number, and if pre-packaged or patched then say
     so.

   * A test program that makes it possible for us to reproduce the bug.
     Include instructions on how to run the program.

   * A description of what is wrong.  If the results are incorrect, in
     what way.  If you get a crash, say so.

   * If you get a crash, include a stack backtrace from the debugger if
     it's informative ('where' in 'gdb', or '$C' in 'adb').

   * Please do not send core dumps, executables or 'strace's.

   * The configuration options you used when building MPIR, if any.

   * The name of the compiler and its version.  For 'gcc', get the
     version with 'gcc -v', otherwise perhaps 'what `which cc`', or
     similar.

   * The output from running 'uname -a'.

   * The output from running './config.guess', and from running
     './configfsf.guess' (might be the same).

   * If the bug is related to 'configure', then the contents of
     'config.log'.

   * If the bug is related to an 'asm' file not assembling, then the
     contents of 'config.m4' and the offending line or lines from the
     temporary 'mpn/tmp-<file>.s'.

   Please make an effort to produce a self-contained report, with
something definite that can be tested or debugged.  Vague queries or
piecemeal messages are difficult to act on and don't help the
development effort.

   It is not uncommon that an observed problem is actually due to a bug
in the compiler; the MPIR code tends to explore interesting corners in
compilers.

   If your bug report is good, we will do our best to help you get a
corrected version of the library; if the bug report is poor, we won't do
anything about it (except maybe ask you to send a better report).

   Send your report to: <http://groups.google.com/group/mpir-devel>.

   If you think something in this manual is unclear, or downright
incorrect, or if the language needs to be improved, please send a note
to the same address.


File: mpir.info,  Node: Integer Functions,  Next: Rational Number Functions,  Prev: Reporting Bugs,  Up: Top

5 Integer Functions
*******************

This chapter describes the MPIR functions for performing integer
arithmetic.  These functions start with the prefix 'mpz_'.

   MPIR integers are stored in objects of type 'mpz_t'.

* Menu:

* Initializing Integers::
* Assigning Integers::
* Simultaneous Integer Init & Assign::
* Converting Integers::
* Integer Arithmetic::
* Integer Division::
* Integer Exponentiation::
* Integer Roots::
* Number Theoretic Functions::
* Integer Comparisons::
* Integer Logic and Bit Fiddling::
* I/O of Integers::
* Integer Random Numbers::
* Integer Import and Export::
* Miscellaneous Integer Functions::
* Integer Special Functions::


File: mpir.info,  Node: Initializing Integers,  Next: Assigning Integers,  Prev: Integer Functions,  Up: Integer Functions

5.1 Initialization Functions
============================

The functions for integer arithmetic assume that all integer objects are
initialized.  You do that by calling the function 'mpz_init'.  For
example,

     {
       mpz_t integ;
       mpz_init (integ);
       ...
       mpz_add (integ, ...);
       ...
       mpz_sub (integ, ...);

       /* Unless the program is about to exit, do ... */
       mpz_clear (integ);
     }

   As you can see, you can store new values any number of times, once an
object is initialized.

 -- Function: void mpz_init (mpz_t INTEGER)
     Initialize INTEGER, and set its value to 0.

 -- Function: void mpz_inits (mpz_t X, ...)
     Initialize a NULL-terminated list of 'mpz_t' variables, and set
     their values to 0.

 -- Function: void mpz_init2 (mpz_t INTEGER, mp_bitcnt_t N)
     Initialize INTEGER, with space for N bits, and set its value to 0.

     N is only the initial space, INTEGER will grow automatically in the
     normal way, if necessary, for subsequent values stored.
     'mpz_init2' makes it possible to avoid such reallocations if a
     maximum size is known in advance.

 -- Function: void mpz_clear (mpz_t INTEGER)
     Free the space occupied by INTEGER.  Call this function for all
     'mpz_t' variables when you are done with them.

 -- Function: void mpz_clears (mpz_t X, ...)
     Free the space occupied by a NULL-terminated list of 'mpz_t'
     variables.

 -- Function: void mpz_realloc2 (mpz_t INTEGER, mp_bitcnt_t N)
     Change the space allocated for INTEGER to N bits.  The value in
     INTEGER is preserved if it fits, or is set to 0 if not.

     This function can be used to increase the space for a variable in
     order to avoid repeated automatic reallocations, or to decrease it
     to give memory back to the heap.


File: mpir.info,  Node: Assigning Integers,  Next: Simultaneous Integer Init & Assign,  Prev: Initializing Integers,  Up: Integer Functions

5.2 Assignment Functions
========================

These functions assign new values to already initialized integers (*note
Initializing Integers::).

 -- Function: void mpz_set (mpz_t ROP, mpz_t OP)
 -- Function: void mpz_set_ui (mpz_t ROP, mpir_ui OP)
 -- Function: void mpz_set_si (mpz_t ROP, mpir_si OP)
 -- Function: void mpz_set_ux (mpz_t ROP, uintmax_t OP)
 -- Function: void mpz_set_sx (mpz_t ROP, intmax_t OP)
 -- Function: void mpz_set_d (mpz_t ROP, double OP)
 -- Function: void mpz_set_q (mpz_t ROP, mpq_t OP)
 -- Function: void mpz_set_f (mpz_t ROP, mpf_t OP)
     Set the value of ROP from OP.  Note the intmax versions are only
     available if you include the 'stdint.h' header before including
     'mpir.h'.

     'mpz_set_d', 'mpz_set_q' and 'mpz_set_f' truncate OP to make it an
     integer.

 -- Function: int mpz_set_str (mpz_t ROP, char *STR, int BASE)
     Set the value of ROP from STR, a null-terminated C string in base
     BASE.  White space is allowed in the string, and is simply ignored.

     The BASE may vary from 2 to 62, or if BASE is 0, then the leading
     characters are used: '0x' and '0X' for hexadecimal, '0b' and '0B'
     for binary, '0' for octal, or decimal otherwise.

     For bases up to 36, case is ignored; upper-case and lower-case
     letters have the same value.  For bases 37 to 62, upper-case letter
     represent the usual 10..35 while lower-case letter represent
     36..61.

     This function returns 0 if the entire string is a valid number in
     base BASE.  Otherwise it returns -1.

 -- Function: void mpz_swap (mpz_t ROP1, mpz_t ROP2)
     Swap the values ROP1 and ROP2 efficiently.


File: mpir.info,  Node: Simultaneous Integer Init & Assign,  Next: Converting Integers,  Prev: Assigning Integers,  Up: Integer Functions

5.3 Combined Initialization and Assignment Functions
====================================================

For convenience, MPIR provides a parallel series of initialize-and-set
functions which initialize the output and then store the value there.
These functions' names have the form 'mpz_init_set...'

   Here is an example of using one:

     {
       mpz_t pie;
       mpz_init_set_str (pie, "3141592653589793238462643383279502884", 10);
       ...
       mpz_sub (pie, ...);
       ...
       mpz_clear (pie);
     }

Once the integer has been initialized by any of the 'mpz_init_set...'
functions, it can be used as the source or destination operand for the
ordinary integer functions.  Don't use an initialize-and-set function on
a variable already initialized!

 -- Function: void mpz_init_set (mpz_t ROP, mpz_t OP)
 -- Function: void mpz_init_set_ui (mpz_t ROP, mpir_ui OP)
 -- Function: void mpz_init_set_si (mpz_t ROP, mpir_si OP)
 -- Function: void mpz_init_set_ux (mpz_t ROP, uintmax_t OP)
 -- Function: void mpz_init_set_sx (mpz_t ROP, intmax_t OP)
 -- Function: void mpz_init_set_d (mpz_t ROP, double OP)
     Initialize ROP with limb space and set the initial numeric value
     from OP.  Note the intmax versions are only available if you
     include the 'stdint.h' header before including 'mpir.h'.

 -- Function: int mpz_init_set_str (mpz_t ROP, char *STR, int BASE)
     Initialize ROP and set its value like 'mpz_set_str' (see its
     documentation above for details).

     If the string is a correct base BASE number, the function returns
     0; if an error occurs it returns -1.  ROP is initialized even if an
     error occurs.  (I.e., you have to call 'mpz_clear' for it.)


File: mpir.info,  Node: Converting Integers,  Next: Integer Arithmetic,  Prev: Simultaneous Integer Init & Assign,  Up: Integer Functions

5.4 Conversion Functions
========================

This section describes functions for converting MPIR integers to
standard C types.  Functions for converting _to_ MPIR integers are
described in *note Assigning Integers:: and *note I/O of Integers::.

 -- Function: mpir_ui mpz_get_ui (mpz_t OP)
     Return the value of OP as an 'mpir_ui'.

     If OP is too big to fit an 'mpir_ui' then just the least
     significant bits that do fit are returned.  The sign of OP is
     ignored, only the absolute value is used.

 -- Function: mpir_si mpz_get_si (mpz_t OP)
     If OP fits into a 'mpir_si' return the value of OP.  Otherwise
     return the least significant part of OP, with the same sign as OP.

     If OP is too big to fit in a 'mpir_si', the returned result is
     probably not very useful.  To find out if the value will fit, use
     the function 'mpz_fits_slong_p'.

 -- Function: uintmax_t mpz_get_ux (mpz_t OP)
     Return the value of OP as an 'uintmax_t'.

     If OP is too big to fit an 'uintmax_t' then just the least
     significant bits that do fit are returned.  The sign of OP is
     ignored, only the absolute value is used.  Note this function is
     only available if you include 'stdint.h' before including 'mpir.h'.

 -- Function: intmax_t mpz_get_sx (mpz_t OP)
     If OP fits into a 'intmax_t' return the value of OP.  Otherwise
     return the least significant part of OP, with the same sign as OP.

     If OP is too big to fit in a 'intmax_t', the returned result is
     probably not very useful.  Note this function is only available if
     you include the 'stdint.h' header before including 'mpir.h'.

 -- Function: double mpz_get_d (mpz_t OP)
     Convert OP to a 'double', truncating if necessary (ie. rounding
     towards zero).

     If the exponent from the conversion is too big, the result is
     system dependent.  An infinity is returned where available.  A
     hardware overflow trap may or may not occur.

 -- Function: double mpz_get_d_2exp (mpir_si *EXP, mpz_t OP)
     Convert OP to a 'double', truncating if necessary (ie. rounding
     towards zero), and returning the exponent separately.

     The return value is in the range 0.5<=abs(D)<1 and the exponent is
     stored to '*EXP'.  D * 2^EXP is the (truncated) OP value.  If OP is
     zero, the return is 0.0 and 0 is stored to '*EXP'.

     This is similar to the standard C 'frexp' function (*note
     (libc)Normalization Functions::).

 -- Function: char * mpz_get_str (char *STR, int BASE, mpz_t OP)
     Convert OP to a string of digits in base BASE.  The base may vary
     from 2 to 36 or from -2 to -36.

     For BASE in the range 2..36, digits and lower-case letters are
     used; for -2..-36, digits and upper-case letters are used; for
     37..62, digits, upper-case letters, and lower-case letters (in that
     significance order) are used.

     If STR is 'NULL', the result string is allocated using the current
     allocation function (*note Custom Allocation::).  The block will be
     'strlen(str)+1' bytes, that being exactly enough for the string and
     null-terminator.

     If STR is not 'NULL', it should point to a block of storage large
     enough for the result, that being 'mpz_sizeinbase (OP, BASE) + 2'.
     The two extra bytes are for a possible minus sign, and the
     null-terminator.

     A pointer to the result string is returned, being either the
     allocated block, or the given STR.


File: mpir.info,  Node: Integer Arithmetic,  Next: Integer Division,  Prev: Converting Integers,  Up: Integer Functions

5.5 Arithmetic Functions
========================

 -- Function: void mpz_add (mpz_t ROP, mpz_t OP1, mpz_t OP2)
 -- Function: void mpz_add_ui (mpz_t ROP, mpz_t OP1, mpir_ui OP2)
     Set ROP to OP1 + OP2.

 -- Function: void mpz_sub (mpz_t ROP, mpz_t OP1, mpz_t OP2)
 -- Function: void mpz_sub_ui (mpz_t ROP, mpz_t OP1, mpir_ui OP2)
 -- Function: void mpz_ui_sub (mpz_t ROP, mpir_ui OP1, mpz_t OP2)
     Set ROP to OP1 - OP2.

 -- Function: void mpz_mul (mpz_t ROP, mpz_t OP1, mpz_t OP2)
 -- Function: void mpz_mul_si (mpz_t ROP, mpz_t OP1, mpir_si OP2)
 -- Function: void mpz_mul_ui (mpz_t ROP, mpz_t OP1, mpir_ui OP2)
     Set ROP to OP1 times OP2.

 -- Function: void mpz_addmul (mpz_t ROP, mpz_t OP1, mpz_t OP2)
 -- Function: void mpz_addmul_ui (mpz_t ROP, mpz_t OP1, mpir_ui OP2)
     Set ROP to ROP + OP1 times OP2.

 -- Function: void mpz_submul (mpz_t ROP, mpz_t OP1, mpz_t OP2)
 -- Function: void mpz_submul_ui (mpz_t ROP, mpz_t OP1, mpir_ui OP2)
     Set ROP to ROP - OP1 times OP2.

 -- Function: void mpz_mul_2exp (mpz_t ROP, mpz_t OP1, mp_bitcnt_t OP2)
     Set ROP to OP1 times 2 raised to OP2.  This operation can also be
     defined as a left shift by OP2 bits.

 -- Function: void mpz_neg (mpz_t ROP, mpz_t OP)
     Set ROP to -OP.

 -- Function: void mpz_abs (mpz_t ROP, mpz_t OP)
     Set ROP to the absolute value of OP.


File: mpir.info,  Node: Integer Division,  Next: Integer Exponentiation,  Prev: Integer Arithmetic,  Up: Integer Functions

5.6 Division Functions
======================

Division is undefined if the divisor is zero.  Passing a zero divisor to
the division or modulo functions (including the modular powering
functions 'mpz_powm' and 'mpz_powm_ui'), will cause an intentional
division by zero.  This lets a program handle arithmetic exceptions in
these functions the same way as for normal C 'int' arithmetic.

 -- Function: void mpz_cdiv_q (mpz_t Q, mpz_t N, mpz_t D)
 -- Function: void mpz_cdiv_r (mpz_t R, mpz_t N, mpz_t D)
 -- Function: void mpz_cdiv_qr (mpz_t Q, mpz_t R, mpz_t N, mpz_t D)

 -- Function: mpir_ui mpz_cdiv_q_ui (mpz_t Q, mpz_t N, mpir_ui D)
 -- Function: mpir_ui mpz_cdiv_r_ui (mpz_t R, mpz_t N, mpir_ui D)
 -- Function: mpir_ui mpz_cdiv_qr_ui (mpz_t Q, mpz_t R, mpz_t N, mpir_ui
          D)
 -- Function: mpir_ui mpz_cdiv_ui (mpz_t N, mpir_ui D)

 -- Function: void mpz_cdiv_q_2exp (mpz_t Q, mpz_t N, mp_bitcnt_t B)
 -- Function: void mpz_cdiv_r_2exp (mpz_t R, mpz_t N, mp_bitcnt_t B)

 -- Function: void mpz_fdiv_q (mpz_t Q, mpz_t N, mpz_t D)
 -- Function: void mpz_fdiv_r (mpz_t R, mpz_t N, mpz_t D)
 -- Function: void mpz_fdiv_qr (mpz_t Q, mpz_t R, mpz_t N, mpz_t D)

 -- Function: mpir_ui mpz_fdiv_q_ui (mpz_t Q, mpz_t N, mpir_ui D)
 -- Function: mpir_ui mpz_fdiv_r_ui (mpz_t R, mpz_t N, mpir_ui D)
 -- Function: mpir_ui mpz_fdiv_qr_ui (mpz_t Q, mpz_t R, mpz_t N, mpir_ui
          D)
 -- Function: mpir_ui mpz_fdiv_ui (mpz_t N, mpir_ui D)

 -- Function: void mpz_fdiv_q_2exp (mpz_t Q, mpz_t N, mp_bitcnt_t B)
 -- Function: void mpz_fdiv_r_2exp (mpz_t R, mpz_t N, mp_bitcnt_t B)

 -- Function: void mpz_tdiv_q (mpz_t Q, mpz_t N, mpz_t D)
 -- Function: void mpz_tdiv_r (mpz_t R, mpz_t N, mpz_t D)
 -- Function: void mpz_tdiv_qr (mpz_t Q, mpz_t R, mpz_t N, mpz_t D)

 -- Function: mpir_ui mpz_tdiv_q_ui (mpz_t Q, mpz_t N, mpir_ui D)
 -- Function: mpir_ui mpz_tdiv_r_ui (mpz_t R, mpz_t N, mpir_ui D)
 -- Function: mpir_ui mpz_tdiv_qr_ui (mpz_t Q, mpz_t R, mpz_t N, mpir_ui
          D)
 -- Function: mpir_ui mpz_tdiv_ui (mpz_t N, mpir_ui D)

 -- Function: void mpz_tdiv_q_2exp (mpz_t Q, mpz_t N, mp_bitcnt_t B)
 -- Function: void mpz_tdiv_r_2exp (mpz_t R, mpz_t N, mp_bitcnt_t B)


     Divide N by D, forming a quotient Q and/or remainder R.  For the
     '2exp' functions, D=2^B.  The rounding is in three styles, each
     suiting different applications.

        * 'cdiv' rounds Q up towards +infinity, and R will have the
          opposite sign to D.  The 'c' stands for "ceil".

        * 'fdiv' rounds Q down towards -infinity, and R will have the
          same sign as D.  The 'f' stands for "floor".

        * 'tdiv' rounds Q towards zero, and R will have the same sign as
          N.  The 't' stands for "truncate".

     In all cases Q and R will satisfy N=Q*D+R, and R will satisfy
     0<=abs(R)<abs(D).

     The 'q' functions calculate only the quotient, the 'r' functions
     only the remainder, and the 'qr' functions calculate both.  Note
     that for 'qr' the same variable cannot be passed for both Q and R,
     or results will be unpredictable.

     For the 'ui' variants the return value is the remainder, and in
     fact returning the remainder is all the 'div_ui' functions do.  For
     'tdiv' and 'cdiv' the remainder can be negative, so for those the
     return value is the absolute value of the remainder.

     For the '2exp' variants the divisor is 2^B.  These functions are
     implemented as right shifts and bit masks, but of course they round
     the same as the other functions.

     For positive N both 'mpz_fdiv_q_2exp' and 'mpz_tdiv_q_2exp' are
     simple bitwise right shifts.  For negative N, 'mpz_fdiv_q_2exp' is
     effectively an arithmetic right shift treating N as twos complement
     the same as the bitwise logical functions do, whereas
     'mpz_tdiv_q_2exp' effectively treats N as sign and magnitude.

 -- Function: void mpz_mod (mpz_t R, mpz_t N, mpz_t D)
 -- Function: mpir_ui mpz_mod_ui (mpz_t R, mpz_t N, mpir_ui D)
     Set R to N 'mod' D.  The sign of the divisor is ignored; the result
     is always non-negative.

     'mpz_mod_ui' is identical to 'mpz_fdiv_r_ui' above, returning the
     remainder as well as setting R.  See 'mpz_fdiv_ui' above if only
     the return value is wanted.

 -- Function: void mpz_divexact (mpz_t Q, mpz_t N, mpz_t D)
 -- Function: void mpz_divexact_ui (mpz_t Q, mpz_t N, mpir_ui D)
     Set Q to N/D.  These functions produce correct results only when it
     is known in advance that D divides N.

     These routines are much faster than the other division functions,
     and are the best choice when exact division is known to occur, for
     example reducing a rational to lowest terms.

 -- Function: int mpz_divisible_p (mpz_t N, mpz_t D)
 -- Function: int mpz_divisible_ui_p (mpz_t N, mpir_ui D)
 -- Function: int mpz_divisible_2exp_p (mpz_t N, mp_bitcnt_t B)
     Return non-zero if N is exactly divisible by D, or in the case of
     'mpz_divisible_2exp_p' by 2^B.

     N is divisible by D if there exists an integer Q satisfying N =
     Q*D.  Unlike the other division functions, D=0 is accepted and
     following the rule it can be seen that only 0 is considered
     divisible by 0.

 -- Function: int mpz_congruent_p (mpz_t N, mpz_t C, mpz_t D)
 -- Function: int mpz_congruent_ui_p (mpz_t N, mpir_ui C, mpir_ui D)
 -- Function: int mpz_congruent_2exp_p (mpz_t N, mpz_t C, mp_bitcnt_t B)
     Return non-zero if N is congruent to C modulo D, or in the case of
     'mpz_congruent_2exp_p' modulo 2^B.

     N is congruent to C mod D if there exists an integer Q satisfying N
     = C + Q*D.  Unlike the other division functions, D=0 is accepted
     and following the rule it can be seen that N and C are considered
     congruent mod 0 only when exactly equal.


File: mpir.info,  Node: Integer Exponentiation,  Next: Integer Roots,  Prev: Integer Division,  Up: Integer Functions

5.7 Exponentiation Functions
============================

 -- Function: void mpz_powm (mpz_t ROP, mpz_t BASE, mpz_t EXP, mpz_t
          MOD)
 -- Function: void mpz_powm_ui (mpz_t ROP, mpz_t BASE, mpir_ui EXP,
          mpz_t MOD)
     Set ROP to (BASE raised to EXP) modulo MOD.

     A negative EXP is supported in 'mpz_powm' if an inverse BASE^-1 mod
     MOD exists (see 'mpz_invert' in *note Number Theoretic
     Functions::).  If an inverse doesn't exist then a divide by zero is
     raised.

 -- Function: void mpz_pow_ui (mpz_t ROP, mpz_t BASE, mpir_ui EXP)
 -- Function: void mpz_ui_pow_ui (mpz_t ROP, mpir_ui BASE, mpir_ui EXP)
     Set ROP to BASE raised to EXP.  The case 0^0 yields 1.


File: mpir.info,  Node: Integer Roots,  Next: Number Theoretic Functions,  Prev: Integer Exponentiation,  Up: Integer Functions

5.8 Root Extraction Functions
=============================

 -- Function: int mpz_root (mpz_t ROP, mpz_t OP, mpir_ui N)
     Set ROP to the truncated integer part of the Nth root of OP.
     Return non-zero if the computation was exact, i.e., if OP is ROP to
     the Nth power.

 -- Function: void mpz_nthroot (mpz_t ROP, mpz_t OP, mpir_ui N)
     Set ROP to the truncated integer part of the Nth root of OP.

 -- Function: void mpz_rootrem (mpz_t ROOT, mpz_t REM, mpz_t U, mpir_ui
          N)
     Set ROOT to the truncated integer part of the Nth root of U.  Set
     REM to the remainder, U-ROOT**N.

 -- Function: void mpz_sqrt (mpz_t ROP, mpz_t OP)
     Set ROP to the truncated integer part of the square root of OP.

 -- Function: void mpz_sqrtrem (mpz_t ROP1, mpz_t ROP2, mpz_t OP)
     Set ROP1 to the truncated integer part of the square root of OP,
     like 'mpz_sqrt'.  Set ROP2 to the remainder OP-ROP1*ROP1, which
     will be zero if OP is a perfect square.

     If ROP1 and ROP2 are the same variable, the results are undefined.

 -- Function: int mpz_perfect_power_p (mpz_t OP)
     Return non-zero if OP is a perfect power, i.e., if there exist
     integers A and B, with B>1, such that OP equals A raised to the
     power B.

     Under this definition both 0 and 1 are considered to be perfect
     powers.  Negative values of OP are accepted, but of course can only
     be odd perfect powers.

 -- Function: int mpz_perfect_square_p (mpz_t OP)
     Return non-zero if OP is a perfect square, i.e., if the square root
     of OP is an integer.  Under this definition both 0 and 1 are
     considered to be perfect squares.


File: mpir.info,  Node: Number Theoretic Functions,  Next: Integer Comparisons,  Prev: Integer Roots,  Up: Integer Functions

5.9 Number Theoretic Functions
==============================

 -- Function: int mpz_probable_prime_p (mpz_t N, gmp_randstate_t STATE,
          int PROB, mpir_ui DIV)
     Determine whether N is a probable prime with the chance of error
     being at most 1 in 2^prob.  return value is 1 if N is probably
     prime, or 0 if N is definitely composite.

     This function does some trial divisions to speed up the average
     case, then some probabilistic primality tests to achieve the
     desired level of error.

     DIV can be used to inform the function that trial division up to
     DIV has already been performed on N and so N has NO divisors <=
     DIV.Use 0 to inform the function that no trial division has been
     done.

     *This function interface is preliminary and may change in the
     future.*

 -- Function: int mpz_likely_prime_p (mpz_t N, gmp_randstate_t STATE,
          mpir_ui DIV)
     Determine whether N is likely a prime, i.e.  you can consider it a
     prime for practical purposes.  return value is 1 if N can be
     considered prime, or 0 if N is definitely composite.

     This function does some trial divisions to speed up the average
     case, then some probabilistic primality tests.  The term "likely"
     refers to the fact that the number will not have small factors.

     DIV can be used to inform the function that trial division up to
     DIV has already been performed on N and so N has NO divisors <= DIV

     *This function interface is preliminary and may change in the
     future.*

 -- Function: int mpz_probab_prime_p (mpz_t N, int REPS)
     Determine whether N is prime.  Return 2 if N is definitely prime,
     return 1 if N is probably prime (without being certain), or return
     0 if N is definitely composite.

     This function does some trial divisions, then some Miller-Rabin
     probabilistic primality tests.  REPS controls how many such tests
     are done, 5 to 10 is a reasonable number, more will reduce the
     chances of a composite being returned as "probably prime".

     Miller-Rabin and similar tests can be more properly called
     compositeness tests.  Numbers which fail are known to be composite
     but those which pass might be prime or might be composite.  Only a
     few composites pass, hence those which pass are considered probably
     prime.

     *This function is obsolete.  It will disappear from future MPIR
     releases.*

 -- Function: void mpz_nextprime (mpz_t ROP, mpz_t OP)
     Set ROP to the next prime greater than OP.

     This function uses a probabilistic algorithm to identify primes.
     For practical purposes it's adequate, the chance of a composite
     passing will be extremely small.  However, despite the name, it
     does not guarantee primality.

     *This function is obsolete.  It will disappear from future MPIR
     releases.*

 -- Function: void mpz_next_prime_candidate (mpz_t ROP, mpz_t OP,
          gmp_randstate_t STATE)
     Set ROP to the next candidate prime greater than OP.  Note that
     this function will occasionally return composites.  It is designed
     to give a quick method for generating numbers which do not have
     small prime factors (less than 1000) and which pass a small number
     of rounds of Miller-Rabin (just two rounds).The test is designed
     for speed, assuming that a high quality followup test can then be
     run to ensure primality.

     The variable STATE must be initialized by calling one of the
     'gmp_randinit' functions (*note Random State Initialization::)
     before invoking this function.

 -- Function: void mpz_gcd (mpz_t ROP, mpz_t OP1, mpz_t OP2)
     Set ROP to the greatest common divisor of OP1 and OP2.  The result
     is always positive even if one or both input operands are negative.

 -- Function: mpir_ui mpz_gcd_ui (mpz_t ROP, mpz_t OP1, mpir_ui OP2)
     Compute the greatest common divisor of OP1 and OP2.  If ROP is not
     'NULL', store the result there.

     If the result is small enough to fit in an 'mpir_ui', it is
     returned.  If the result does not fit, 0 is returned, and the
     result is equal to the argument OP1.  Note that the result will
     always fit if OP2 is non-zero.

 -- Function: void mpz_gcdext (mpz_t G, mpz_t S, mpz_t T, const mpz_t A,
          const mpz_t B)
     Set G to the greatest common divisor of A and B, and in addition
     set S and T to coefficients satisfying A*S + B*T = G.  The value in
     G is always positive, even if one or both of A and B are negative
     (or zero if both inputs are zero).  The values in S and T are
     chosen such that normally, abs(S) < abs(B) / (2 G) and abs(T) <
     abs(A) / (2 G), and these relations define S and T uniquely.  There
     are a few exceptional cases:

     If abs(A) = abs(B), then S = 0, T = sgn(B).

     Otherwise, S = sgn(A) if B = 0 or abs(B) = 2 G, and T = sgn(B) if A
     = 0 or abs(A) = 2 G.

     In all cases, S = 0 if and only if G = abs(B), i.e., if B divides A
     or A = B = 0.

     If T is 'NULL' then that value is not computed.

 -- Function: void mpz_lcm (mpz_t ROP, mpz_t OP1, mpz_t OP2)
 -- Function: void mpz_lcm_ui (mpz_t ROP, mpz_t OP1, mpir_ui OP2)
     Set ROP to the least common multiple of OP1 and OP2.  ROP is always
     positive, irrespective of the signs of OP1 and OP2.  ROP will be
     zero if either OP1 or OP2 is zero.

 -- Function: int mpz_invert (mpz_t ROP, mpz_t OP1, mpz_t OP2)
     Compute the inverse of OP1 modulo OP2 and put the result in ROP.
     If the inverse exists, the return value is non-zero and ROP will
     satisfy 0 <= ROP < OP2.  If an inverse doesn't exist the return
     value is zero and ROP is undefined.

 -- Function: int mpz_jacobi (mpz_t A, mpz_t B)
     Calculate the Jacobi symbol (A/B).  This is defined only for B odd.

 -- Function: int mpz_legendre (mpz_t A, mpz_t P)
     Calculate the Legendre symbol (A/P).  This is defined only for P an
     odd positive prime, and for such P it's identical to the Jacobi
     symbol.

 -- Function: int mpz_kronecker (mpz_t A, mpz_t B)
 -- Function: int mpz_kronecker_si (mpz_t A, mpir_si B)
 -- Function: int mpz_kronecker_ui (mpz_t A, mpir_ui B)
 -- Function: int mpz_si_kronecker (mpir_si A, mpz_t B)
 -- Function: int mpz_ui_kronecker (mpir_ui A, mpz_t B)
     Calculate the Jacobi symbol (A/B) with the Kronecker extension
     (a/2)=(2/a) when a odd, or (a/2)=0 when a even.

     When B is odd the Jacobi symbol and Kronecker symbol are identical,
     so 'mpz_kronecker_ui' etc can be used for mixed precision Jacobi
     symbols too.

     For more information see Henri Cohen section 1.4.2 (*note
     References::), or any number theory textbook.  See also the example
     program 'demos/qcn.c' which uses 'mpz_kronecker_ui' on the MPIR
     website.

 -- Function: mp_bitcnt_t mpz_remove (mpz_t ROP, mpz_t OP, mpz_t F)
     Remove all occurrences of the factor F from OP and store the result
     in ROP.  The return value is how many such occurrences were
     removed.

 -- Function: void mpz_fac_ui (mpz_t ROP, unsigned long int N)
 -- Function: void mpz_2fac_ui (mpz_t ROP, unsigned long int N)
 -- Function: void mpz_mfac_uiui (mpz_t ROP, unsigned long int N,
          unsigned long int M)
     Set ROP to the factorial of N: 'mpz_fac_ui' computes the plain
     factorial N!, 'mpz_2fac_ui' computes the double-factorial N!!, and
     'mpz_mfac_uiui' the M-multi-factorial N!^(M).

 -- Function: void mpz_primorial_ui (mpz_t ROP, unsigned long int N)
     Set ROP to the primorial of N, i.e.  the product of all positive
     prime numbers <=N.

 -- Function: void mpz_bin_ui (mpz_t ROP, mpz_t N, mpir_ui K)
 -- Function: void mpz_bin_uiui (mpz_t ROP, mpir_ui N, mpir_ui K)
     Compute the binomial coefficient N over K and store the result in
     ROP.  Negative values of N are supported by 'mpz_bin_ui', using the
     identity bin(-n,k) = (-1)^k * bin(n+k-1,k), see Knuth volume 1
     section 1.2.6 part G.

 -- Function: void mpz_fib_ui (mpz_t FN, mpir_ui N)
 -- Function: void mpz_fib2_ui (mpz_t FN, mpz_t FNSUB1, mpir_ui N)
     'mpz_fib_ui' sets FN to to F[n], the N'th Fibonacci number.
     'mpz_fib2_ui' sets FN to F[n], and FNSUB1 to F[n-1].

     These functions are designed for calculating isolated Fibonacci
     numbers.  When a sequence of values is wanted it's best to start
     with 'mpz_fib2_ui' and iterate the defining F[n+1]=F[n]+F[n-1] or
     similar.

 -- Function: void mpz_lucnum_ui (mpz_t LN, mpir_ui N)
 -- Function: void mpz_lucnum2_ui (mpz_t LN, mpz_t LNSUB1, mpir_ui N)
     'mpz_lucnum_ui' sets LN to to L[n], the N'th Lucas number.
     'mpz_lucnum2_ui' sets LN to L[n], and LNSUB1 to L[n-1].

     These functions are designed for calculating isolated Lucas
     numbers.  When a sequence of values is wanted it's best to start
     with 'mpz_lucnum2_ui' and iterate the defining L[n+1]=L[n]+L[n-1]
     or similar.

     The Fibonacci numbers and Lucas numbers are related sequences, so
     it's never necessary to call both 'mpz_fib2_ui' and
     'mpz_lucnum2_ui'.  The formulas for going from Fibonacci to Lucas
     can be found in *note Lucas Numbers Algorithm::, the reverse is
     straightforward too.


File: mpir.info,  Node: Integer Comparisons,  Next: Integer Logic and Bit Fiddling,  Prev: Number Theoretic Functions,  Up: Integer Functions

5.10 Comparison Functions
=========================

 -- Function: int mpz_cmp (mpz_t OP1, mpz_t OP2)
 -- Function: int mpz_cmp_d (mpz_t OP1, double OP2)
 -- Macro: int mpz_cmp_si (mpz_t OP1, mpir_si OP2)
 -- Macro: int mpz_cmp_ui (mpz_t OP1, mpir_ui OP2)
     Compare OP1 and OP2.  Return a positive value if OP1 > OP2, zero if
     OP1 = OP2, or a negative value if OP1 < OP2.

     'mpz_cmp_ui' and 'mpz_cmp_si' are macros and will evaluate their
     arguments more than once.  'mpz_cmp_d' can be called with an
     infinity, but results are undefined for a NaN.

 -- Function: int mpz_cmpabs (mpz_t OP1, mpz_t OP2)
 -- Function: int mpz_cmpabs_d (mpz_t OP1, double OP2)
 -- Function: int mpz_cmpabs_ui (mpz_t OP1, mpir_ui OP2)
     Compare the absolute values of OP1 and OP2.  Return a positive
     value if abs(OP1) > abs(OP2), zero if abs(OP1) = abs(OP2), or a
     negative value if abs(OP1) < abs(OP2).

     'mpz_cmpabs_d' can be called with an infinity, but results are
     undefined for a NaN.

 -- Macro: int mpz_sgn (mpz_t OP)
     Return +1 if OP > 0, 0 if OP = 0, and -1 if OP < 0.

     This function is actually implemented as a macro.  It evaluates its
     argument multiple times.


File: mpir.info,  Node: Integer Logic and Bit Fiddling,  Next: I/O of Integers,  Prev: Integer Comparisons,  Up: Integer Functions

5.11 Logical and Bit Manipulation Functions
===========================================

These functions behave as if twos complement arithmetic were used
(although sign-magnitude is the actual implementation).  The least
significant bit is number 0.

 -- Function: void mpz_and (mpz_t ROP, mpz_t OP1, mpz_t OP2)
     Set ROP to OP1 bitwise-and OP2.

 -- Function: void mpz_ior (mpz_t ROP, mpz_t OP1, mpz_t OP2)
     Set ROP to OP1 bitwise inclusive-or OP2.

 -- Function: void mpz_xor (mpz_t ROP, mpz_t OP1, mpz_t OP2)
     Set ROP to OP1 bitwise exclusive-or OP2.

 -- Function: void mpz_com (mpz_t ROP, mpz_t OP)
     Set ROP to the one's complement of OP.

 -- Function: mp_bitcnt_t mpz_popcount (mpz_t OP)
     If OP>=0, return the population count of OP, which is the number of
     1 bits in the binary representation.  If OP<0, the number of 1s is
     infinite, and the return value is ULONG_MAX, the largest possible
     'mp_bitcnt_t'.

 -- Function: mp_bitcnt_t mpz_hamdist (mpz_t OP1, mpz_t OP2)
     If OP1 and OP2 are both >=0 or both <0, return the hamming distance
     between the two operands, which is the number of bit positions
     where OP1 and OP2 have different bit values.  If one operand is >=0
     and the other <0 then the number of bits different is infinite, and
     the return value is the largest possible 'imp_bitcnt_t'.

 -- Function: mp_bitcnt_t mpz_scan0 (mpz_t OP, mp_bitcnt_t STARTING_BIT)
 -- Function: mp_bitcnt_t mpz_scan1 (mpz_t OP, mp_bitcnt_t STARTING_BIT)
     Scan OP, starting from bit STARTING_BIT, towards more significant
     bits, until the first 0 or 1 bit (respectively) is found.  Return
     the index of the found bit.

     If the bit at STARTING_BIT is already what's sought, then
     STARTING_BIT is returned.

     If there's no bit found, then the largest possible 'mp_bitcnt_t' is
     returned.  This will happen in 'mpz_scan0' past the end of a
     positive number, or 'mpz_scan1' past the end of a nonnegative
     number.

 -- Function: void mpz_setbit (mpz_t ROP, mp_bitcnt_t BIT_INDEX)
     Set bit BIT_INDEX in ROP.

 -- Function: void mpz_clrbit (mpz_t ROP, mp_bitcnt_t BIT_INDEX)
     Clear bit BIT_INDEX in ROP.

 -- Function: void mpz_combit (mpz_t ROP, mp_bitcnt_t BIT_INDEX)
     Complement bit BIT_INDEX in ROP.

 -- Function: int mpz_tstbit (mpz_t OP, mp_bitcnt_t BIT_INDEX)
     Test bit BIT_INDEX in OP and return 0 or 1 accordingly.


File: mpir.info,  Node: I/O of Integers,  Next: Integer Random Numbers,  Prev: Integer Logic and Bit Fiddling,  Up: Integer Functions

5.12 Input and Output Functions
===============================

Functions that perform input from a stdio stream, and functions that
output to a stdio stream.  Passing a 'NULL' pointer for a STREAM
argument to any of these functions will make them read from 'stdin' and
write to 'stdout', respectively.

   When using any of these functions, it is a good idea to include
'stdio.h' before 'mpir.h', since that will allow 'mpir.h' to define
prototypes for these functions.

 -- Function: size_t mpz_out_str (FILE *STREAM, int BASE, mpz_t OP)
     Output OP on stdio stream STREAM, as a string of digits in base
     BASE.  The base argument may vary from 2 to 62 or from -2 to -36.

     For BASE in the range 2..36, digits and lower-case letters are
     used; for -2..-36, digits and upper-case letters are used; for
     37..62, digits, upper-case letters, and lower-case letters (in that
     significance order) are used.

     Return the number of bytes written, or if an error occurred, return
     0.

 -- Function: size_t mpz_inp_str (mpz_t ROP, FILE *STREAM, int BASE)
     Input a possibly white-space preceded string in base BASE from
     stdio stream STREAM, and put the read integer in ROP.

     The BASE may vary from 2 to 62, or if BASE is 0, then the leading
     characters are used: '0x' and '0X' for hexadecimal, '0b' and '0B'
     for binary, '0' for octal, or decimal otherwise.

     For bases up to 36, case is ignored; upper-case and lower-case
     letters have the same value.  For bases 37 to 62, upper-case letter
     represent the usual 10..35 while lower-case letter represent
     36..61.

     Return the number of bytes read, or if an error occurred, return 0.

 -- Function: size_t mpz_out_raw (FILE *STREAM, mpz_t OP)
     Output OP on stdio stream STREAM, in raw binary format.  The
     integer is written in a portable format, with 4 bytes of size
     information, and that many bytes of limbs.  Both the size and the
     limbs are written in decreasing significance order (i.e., in
     big-endian).

     The output can be read with 'mpz_inp_raw'.

     Return the number of bytes written, or if an error occurred, return
     0.

     The output of this can not be read by 'mpz_inp_raw' from GMP 1,
     because of changes necessary for compatibility between 32-bit and
     64-bit machines.

 -- Function: size_t mpz_inp_raw (mpz_t ROP, FILE *STREAM)
     Input from stdio stream STREAM in the format written by
     'mpz_out_raw', and put the result in ROP.  Return the number of
     bytes read, or if an error occurred, return 0.

     This routine can read the output from 'mpz_out_raw' also from GMP
     1, in spite of changes necessary for compatibility between 32-bit
     and 64-bit machines.


File: mpir.info,  Node: Integer Random Numbers,  Next: Integer Import and Export,  Prev: I/O of Integers,  Up: Integer Functions

5.13 Random Number Functions
============================

The random number functions of MPIR come in two groups; older function
that rely on a global state, and newer functions that accept a state
parameter that is read and modified.  Please see the *note Random Number
Functions:: for more information on how to use and not to use random
number functions.

 -- Function: void mpz_urandomb (mpz_t ROP, gmp_randstate_t STATE,
          mp_bitcnt_t N)
     Generate a uniformly distributed random integer in the range 0 to
     2^N-1, inclusive.

     The variable STATE must be initialized by calling one of the
     'gmp_randinit' functions (*note Random State Initialization::)
     before invoking this function.

 -- Function: void mpz_urandomm (mpz_t ROP, gmp_randstate_t STATE, mpz_t
          N)
     Generate a uniform random integer in the range 0 to N-1, inclusive.

     The variable STATE must be initialized by calling one of the
     'gmp_randinit' functions (*note Random State Initialization::)
     before invoking this function.

 -- Function: void mpz_rrandomb (mpz_t ROP, gmp_randstate_t STATE,
          mp_bitcnt_t N)
     Generate a random integer with long strings of zeros and ones in
     the binary representation.  Useful for testing functions and
     algorithms, since this kind of random numbers have proven to be
     more likely to trigger corner-case bugs.  The random number will be
     in the range 0 to 2^N-1, inclusive.

     The variable STATE must be initialized by calling one of the
     'gmp_randinit' functions (*note Random State Initialization::)
     before invoking this function.


File: mpir.info,  Node: Integer Import and Export,  Next: Miscellaneous Integer Functions,  Prev: Integer Random Numbers,  Up: Integer Functions

5.14 Integer Import and Export
==============================

'mpz_t' variables can be converted to and from arbitrary words of binary
data with the following functions.

 -- Function: void mpz_import (mpz_t ROP, size_t COUNT, int ORDER,
          size_t SIZE, int ENDIAN, size_t NAILS, const void *OP)
     Set ROP from an array of word data at OP.

     The parameters specify the format of the data.  COUNT many words
     are read, each SIZE bytes.  ORDER can be 1 for most significant
     word first or -1 for least significant first.  Within each word
     ENDIAN can be 1 for most significant byte first, -1 for least
     significant first, or 0 for the native endianness of the host CPU.
     The most significant NAILS bits of each word are skipped, this can
     be 0 to use the full words.

     There is no sign taken from the data, ROP will simply be a positive
     integer.  An application can handle any sign itself, and apply it
     for instance with 'mpz_neg'.

     There are no data alignment restrictions on OP, any address is
     allowed.

     Here's an example converting an array of 'mpir_ui' data, most
     significant element first, and host byte order within each value.

          mpir_ui  a[20];
          mpz_t          z;
          mpz_import (z, 20, 1, sizeof(a[0]), 0, 0, a);

     This example assumes the full 'sizeof' bytes are used for data in
     the given type, which is usually true, and certainly true for
     'mpir_ui' everywhere we know of.  However on Cray vector systems it
     may be noted that 'short' and 'int' are always stored in 8 bytes
     (and with 'sizeof' indicating that) but use only 32 or 46 bits.
     The NAILS feature can account for this, by passing for instance
     '8*sizeof(int)-INT_BIT'.

 -- Function: void * mpz_export (void *ROP, size_t *COUNTP, int ORDER,
          size_t SIZE, int ENDIAN, size_t NAILS, mpz_t OP)
     Fill ROP with word data from OP.

     The parameters specify the format of the data produced.  Each word
     will be SIZE bytes and ORDER can be 1 for most significant word
     first or -1 for least significant first.  Within each word ENDIAN
     can be 1 for most significant byte first, -1 for least significant
     first, or 0 for the native endianness of the host CPU.  The most
     significant NAILS bits of each word are unused and set to zero,
     this can be 0 to produce full words.

     The number of words produced is written to '*COUNTP', or COUNTP can
     be 'NULL' to discard the count.  ROP must have enough space for the
     data, or if ROP is 'NULL' then a result array of the necessary size
     is allocated using the current MPIR allocation function (*note
     Custom Allocation::).  In either case the return value is the
     destination used, either ROP or the allocated block.

     If OP is non-zero then the most significant word produced will be
     non-zero.  If OP is zero then the count returned will be zero and
     nothing written to ROP.  If ROP is 'NULL' in this case, no block is
     allocated, just 'NULL' is returned.

     The sign of OP is ignored, just the absolute value is exported.  An
     application can use 'mpz_sgn' to get the sign and handle it as
     desired.  (*note Integer Comparisons::)

     There are no data alignment restrictions on ROP, any address is
     allowed.

     When an application is allocating space itself the required size
     can be determined with a calculation like the following.  Since
     'mpz_sizeinbase' always returns at least 1, 'count' here will be at
     least one, which avoids any portability problems with 'malloc(0)',
     though if 'z' is zero no space at all is actually needed (or
     written).

          numb = 8*size - nail;
          count = (mpz_sizeinbase (z, 2) + numb-1) / numb;
          p = malloc (count * size);


File: mpir.info,  Node: Miscellaneous Integer Functions,  Next: Integer Special Functions,  Prev: Integer Import and Export,  Up: Integer Functions

5.15 Miscellaneous Functions
============================

 -- Function: int mpz_fits_ulong_p (mpz_t OP)
 -- Function: int mpz_fits_slong_p (mpz_t OP)
 -- Function: int mpz_fits_uint_p (mpz_t OP)
 -- Function: int mpz_fits_sint_p (mpz_t OP)
 -- Function: int mpz_fits_ushort_p (mpz_t OP)
 -- Function: int mpz_fits_sshort_p (mpz_t OP)
     Return non-zero iff the value of OP fits in an 'unsigned long',
     'long', 'unsigned int', 'signed int', 'unsigned short int', or
     'signed short int', respectively.  Otherwise, return zero.

 -- Macro: int mpz_odd_p (mpz_t OP)
 -- Macro: int mpz_even_p (mpz_t OP)
     Determine whether OP is odd or even, respectively.  Return non-zero
     if yes, zero if no.  These macros evaluate their argument more than
     once.

 -- Function: size_t mpz_sizeinbase (mpz_t OP, int BASE)
     Return the size of OP measured in number of digits in the given
     BASE.  BASE can vary from 2 to 36.  The sign of OP is ignored, just
     the absolute value is used.  The result will be either exact or 1
     too big.  If BASE is a power of 2, the result is always exact.  If
     OP is zero the return value is always 1.

     This function can be used to determine the space required when
     converting OP to a string.  The right amount of allocation is
     normally two more than the value returned by 'mpz_sizeinbase', one
     extra for a minus sign and one for the null-terminator.

     It will be noted that 'mpz_sizeinbase(OP,2)' can be used to locate
     the most significant 1 bit in OP, counting from 1.  (Unlike the
     bitwise functions which start from 0, *Note Logical and Bit
     Manipulation Functions: Integer Logic and Bit Fiddling.)


File: mpir.info,  Node: Integer Special Functions,  Prev: Miscellaneous Integer Functions,  Up: Integer Functions

5.16 Special Functions
======================

The functions in this section are for various special purposes.  Most
applications will not need them.

 -- Function: void mpz_array_init (mpz_t INTEGER_ARRAY, size_t
          ARRAY_SIZE, mp_size_t FIXED_NUM_BITS)
     This is a special type of initialization.  *Fixed* space of
     FIXED_NUM_BITS is allocated to each of the ARRAY_SIZE integers in
     INTEGER_ARRAY.  There is no way to free the storage allocated by
     this function.  Don't call 'mpz_clear'!

     The INTEGER_ARRAY parameter is the first 'mpz_t' in the array.  For
     example,

          mpz_t  arr[20000];
          mpz_array_init (arr[0], 20000, 512);

     This function is only intended for programs that create a large
     number of integers and need to reduce memory usage by avoiding the
     overheads of allocating and reallocating lots of small blocks.  In
     normal programs this function is not recommended.

     The space allocated to each integer by this function will not be
     automatically increased, unlike the normal 'mpz_init', so an
     application must ensure it is sufficient for any value stored.  The
     following space requirements apply to various routines,

        * 'mpz_abs', 'mpz_neg', 'mpz_set', 'mpz_set_si' and 'mpz_set_ui'
          need room for the value they store.

        * 'mpz_add', 'mpz_add_ui', 'mpz_sub' and 'mpz_sub_ui' need room
          for the larger of the two operands, plus an extra
          'mp_bits_per_limb'.

        * 'mpz_mul', 'mpz_mul_ui' and 'mpz_mul_ui' need room for the sum
          of the number of bits in their operands, but each rounded up
          to a multiple of 'mp_bits_per_limb'.

        * 'mpz_swap' can be used between two array variables, but not
          between an array and a normal variable.

     For other functions, or if in doubt, the suggestion is to calculate
     in a regular 'mpz_init' variable and copy the result to an array
     variable with 'mpz_set'.

     *This function is obsolete.  It will disappear from future MPIR
     releases.*

 -- Function: void * _mpz_realloc (mpz_t INTEGER, mp_size_t NEW_ALLOC)
     Change the space for INTEGER to NEW_ALLOC limbs.  The value in
     INTEGER is preserved if it fits, or is set to 0 if not.  The return
     value is not useful to applications and should be ignored.

     'mpz_realloc2' is the preferred way to accomplish allocation
     changes like this.  'mpz_realloc2' and '_mpz_realloc' are the same
     except that '_mpz_realloc' takes its size in limbs.

 -- Function: mp_limb_t mpz_getlimbn (mpz_t OP, mp_size_t N)
     Return limb number N from OP.  The sign of OP is ignored, just the
     absolute value is used.  The least significant limb is number 0.

     'mpz_size' can be used to find how many limbs make up OP.
     'mpz_getlimbn' returns zero if N is outside the range 0 to
     'mpz_size(OP)-1'.

 -- Function: size_t mpz_size (mpz_t OP)
     Return the size of OP measured in number of limbs.  If OP is zero,
     the returned value will be zero.

 -- Function: const mp_limb_t * mpz_limbs_read (const mpz_t X)
     Return a pointer to the limb array representing the absolute value
     of X.  The size of the array is 'mpz_size(X)'.  Intended for read
     access only.

 -- Function: mp_limb_t * mpz_limbs_write (mpz_t X, mp_size_t N)
 -- Function: mp_limb_t * mpz_limbs_modify (mpz_t X, mp_size_t N)
     Return a pointer to the limb array, intended for write access.  The
     array is reallocated as needed, to make room for N limbs.  Requires
     N > 0.  The 'mpz_limbs_modify' function returns an array that holds
     the old absolute value of X, while 'mpz_limbs_write' may destroy
     the old value and return an array with unspecified contents.

 -- Function: void mpz_limbs_finish (mpz_t X, mp_size_t S)
     Updates the internal size field of X.  Used after writing to the
     limb array pointer returned by 'mpz_limbs_write' or
     'mpz_limbs_modify' is completed.  The array should contain abs(S)
     valid limbs, representing the new absolute value for X, and the
     sign of X is taken from the sign of S.  This function never
     reallocates X, so the limb pointer remains valid.

     void foo (mpz_t x)
     {
       mp_size_t n, i;
       mp_limb_t *xp;

       n = mpz_size (x);
       xp = mpz_limbs_modify (x, 2*n);
       for (i = 0; i < n; i++)
         xp[n+i] = xp[n-1-i];
       mpz_limbs_finish (x, mpz_sgn (x) < 0 ? - 2*n : 2*n);
     }

 -- Function: mpz_srcptr mpz_roinit_n (mpz_t X, const mp_limb_t *XP,
          mp_size_t XS)
     Special initialization of X, using the given limb array and size.
     X should be treated as read-only: it can be passed safely as input
     to any mpz function, but not as an output.  The array XP must point
     to at least a readable limb, its size is abs(XS), and the sign of X
     is the sign of XS.  For convenience, the function returns X, but
     cast to a const pointer type.

     void foo (mpz_t x)
     {
       static const mp_limb_t y[3] = { 0x1, 0x2, 0x3 };
       mpz_t tmp;
       mpz_add (x, x, mpz_roinit_n (tmp, y, 3));
     }

 -- Macro: mpz_t MPZ_ROINIT_N (mp_limb_t *XP, mp_size_t XS)
     This macro expands to an initializer which can be assigned to an
     mpz_t variable.  The limb array XP must point to at least a
     readable limb, moreover, unlike the 'mpz_roinit_n' function, the
     array must be normalized: if XS is non-zero, then 'XP[abs(XS)-1]'
     must be non-zero.  Intended primarily for constant values.  Using
     it for non-constant values requires a C compiler supporting C99.

     void foo (mpz_t x)
     {
       static const mp_limb_t ya[3] = { 0x1, 0x2, 0x3 };
       static const mpz_t y = MPZ_ROINIT_N ((mp_limb_t *) ya, 3);

       mpz_add (x, x, y);
     }


File: mpir.info,  Node: Rational Number Functions,  Next: Floating-point Functions,  Prev: Integer Functions,  Up: Top

6 Rational Number Functions
***************************

This chapter describes the MPIR functions for performing arithmetic on
rational numbers.  These functions start with the prefix 'mpq_'.

   Rational numbers are stored in objects of type 'mpq_t'.

   All rational arithmetic functions assume operands have a canonical
form, and canonicalize their result.  The canonical from means that the
denominator and the numerator have no common factors, and that the
denominator is positive.  Zero has the unique representation 0/1.

   Pure assignment functions do not canonicalize the assigned variable.
It is the responsibility of the user to canonicalize the assigned
variable before any arithmetic operations are performed on that
variable.

 -- Function: void mpq_canonicalize (mpq_t OP)
     Remove any factors that are common to the numerator and denominator
     of OP, and make the denominator positive.

* Menu:

* Initializing Rationals::
* Rational Conversions::
* Rational Arithmetic::
* Comparing Rationals::
* Applying Integer Functions::
* I/O of Rationals::


File: mpir.info,  Node: Initializing Rationals,  Next: Rational Conversions,  Prev: Rational Number Functions,  Up: Rational Number Functions

6.1 Initialization and Assignment Functions
===========================================

 -- Function: void mpq_init (mpq_t DEST_RATIONAL)
     Initialize DEST_RATIONAL and set it to 0/1.  Each variable should
     normally only be initialized once, or at least cleared out (using
     the function 'mpq_clear') between each initialization.

 -- Function: void mpq_inits (mpq_t X, ...)
     Initialize a NULL-terminated list of 'mpq_t' variables, and set
     their values to 0/1.

 -- Function: void mpq_clear (mpq_t RATIONAL_NUMBER)
     Free the space occupied by RATIONAL_NUMBER.  Make sure to call this
     function for all 'mpq_t' variables when you are done with them.

 -- Function: void mpq_clears (mpq_t X, ...)
     Free the space occupied by a NULL-terminated list of 'mpq_t'
     variables.

 -- Function: void mpq_set (mpq_t ROP, mpq_t OP)
 -- Function: void mpq_set_z (mpq_t ROP, mpz_t OP)
     Assign ROP from OP.

 -- Function: void mpq_set_ui (mpq_t ROP, mpir_ui OP1, mpir_ui OP2)
 -- Function: void mpq_set_si (mpq_t ROP, mpir_si OP1, mpir_ui OP2)
     Set the value of ROP to OP1/OP2.  Note that if OP1 and OP2 have
     common factors, ROP has to be passed to 'mpq_canonicalize' before
     any operations are performed on ROP.

 -- Function: int mpq_set_str (mpq_t ROP, char *STR, int BASE)
     Set ROP from a null-terminated string STR in the given BASE.

     The string can be an integer like "41" or a fraction like "41/152".
     The fraction must be in canonical form (*note Rational Number
     Functions::), or if not then 'mpq_canonicalize' must be called.

     The numerator and optional denominator are parsed the same as in
     'mpz_set_str' (*note Assigning Integers::).  White space is allowed
     in the string, and is simply ignored.  The BASE can vary from 2 to
     62, or if BASE is 0 then the leading characters are used: '0x' or
     '0X' for hex, '0b' or '0B' for binary, '0' for octal, or decimal
     otherwise.  Note that this is done separately for the numerator and
     denominator, so for instance '0xEF/100' is 239/100, whereas
     '0xEF/0x100' is 239/256.

     The return value is 0 if the entire string is a valid number, or -1
     if not.

 -- Function: void mpq_swap (mpq_t ROP1, mpq_t ROP2)
     Swap the values ROP1 and ROP2 efficiently.


File: mpir.info,  Node: Rational Conversions,  Next: Rational Arithmetic,  Prev: Initializing Rationals,  Up: Rational Number Functions

6.2 Conversion Functions
========================

 -- Function: double mpq_get_d (mpq_t OP)
     Convert OP to a 'double', truncating if necessary (ie. rounding
     towards zero).

     If the exponent from the conversion is too big or too small to fit
     a 'double' then the result is system dependent.  For too big an
     infinity is returned when available.  For too small 0.0 is normally
     returned.  Hardware overflow, underflow and denorm traps may or may
     not occur.

 -- Function: void mpq_set_d (mpq_t ROP, double OP)
 -- Function: void mpq_set_f (mpq_t ROP, mpf_t OP)
     Set ROP to the value of OP.  There is no rounding, this conversion
     is exact.

 -- Function: char * mpq_get_str (char *STR, int BASE, mpq_t OP)
     Convert OP to a string of digits in base BASE.  The base may vary
     from 2 to 36.  The string will be of the form 'num/den', or if the
     denominator is 1 then just 'num'.

     If STR is 'NULL', the result string is allocated using the current
     allocation function (*note Custom Allocation::).  The block will be
     'strlen(str)+1' bytes, that being exactly enough for the string and
     null-terminator.

     If STR is not 'NULL', it should point to a block of storage large
     enough for the result, that being

          mpz_sizeinbase (mpq_numref(OP), BASE)
          + mpz_sizeinbase (mpq_denref(OP), BASE) + 3

     The three extra bytes are for a possible minus sign, possible
     slash, and the null-terminator.

     A pointer to the result string is returned, being either the
     allocated block, or the given STR.


File: mpir.info,  Node: Rational Arithmetic,  Next: Comparing Rationals,  Prev: Rational Conversions,  Up: Rational Number Functions

6.3 Arithmetic Functions
========================

 -- Function: void mpq_add (mpq_t SUM, mpq_t ADDEND1, mpq_t ADDEND2)
     Set SUM to ADDEND1 + ADDEND2.

 -- Function: void mpq_sub (mpq_t DIFFERENCE, mpq_t MINUEND, mpq_t
          SUBTRAHEND)
     Set DIFFERENCE to MINUEND - SUBTRAHEND.

 -- Function: void mpq_mul (mpq_t PRODUCT, mpq_t MULTIPLIER, mpq_t
          MULTIPLICAND)
     Set PRODUCT to MULTIPLIER times MULTIPLICAND.

 -- Function: void mpq_mul_2exp (mpq_t ROP, mpq_t OP1, mp_bitcnt_t OP2)
     Set ROP to OP1 times 2 raised to OP2.

 -- Function: void mpq_div (mpq_t QUOTIENT, mpq_t DIVIDEND, mpq_t
          DIVISOR)
     Set QUOTIENT to DIVIDEND/DIVISOR.

 -- Function: void mpq_div_2exp (mpq_t ROP, mpq_t OP1, mp_bitcnt_t OP2)
     Set ROP to OP1 divided by 2 raised to OP2.

 -- Function: void mpq_neg (mpq_t NEGATED_OPERAND, mpq_t OPERAND)
     Set NEGATED_OPERAND to -OPERAND.

 -- Function: void mpq_abs (mpq_t ROP, mpq_t OP)
     Set ROP to the absolute value of OP.

 -- Function: void mpq_inv (mpq_t INVERTED_NUMBER, mpq_t NUMBER)
     Set INVERTED_NUMBER to 1/NUMBER.  If the new denominator is zero,
     this routine will divide by zero.


File: mpir.info,  Node: Comparing Rationals,  Next: Applying Integer Functions,  Prev: Rational Arithmetic,  Up: Rational Number Functions

6.4 Comparison Functions
========================

 -- Function: int mpq_cmp (mpq_t OP1, mpq_t OP2)
 -- Function: int mpq_cmp_z (const mpq_t OP1, const mpz_t OP2)
     Compare OP1 and OP2.  Return a positive value if OP1 > OP2, zero if
     OP1 = OP2, and a negative value if OP1 < OP2.

     To determine if two rationals are equal, 'mpq_equal' is faster than
     'mpq_cmp'.

 -- Macro: int mpq_cmp_ui (mpq_t OP1, mpir_ui NUM2, mpir_ui DEN2)
 -- Macro: int mpq_cmp_si (mpq_t OP1, mpir_si NUM2, mpir_ui DEN2)
     Compare OP1 and NUM2/DEN2.  Return a positive value if OP1 >
     NUM2/DEN2, zero if OP1 = NUM2/DEN2, and a negative value if OP1 <
     NUM2/DEN2.

     NUM2 and DEN2 are allowed to have common factors.

     These functions are implemented as a macros and evaluate their
     arguments multiple times.

 -- Macro: int mpq_sgn (mpq_t OP)
     Return +1 if OP > 0, 0 if OP = 0, and -1 if OP < 0.

     This function is actually implemented as a macro.  It evaluates its
     arguments multiple times.

 -- Function: int mpq_equal (mpq_t OP1, mpq_t OP2)
     Return non-zero if OP1 and OP2 are equal, zero if they are
     non-equal.  Although 'mpq_cmp' can be used for the same purpose,
     this function is much faster.


File: mpir.info,  Node: Applying Integer Functions,  Next: I/O of Rationals,  Prev: Comparing Rationals,  Up: Rational Number Functions

6.5 Applying Integer Functions to Rationals
===========================================

The set of 'mpq' functions is quite small.  In particular, there are few
functions for either input or output.  The following functions give
direct access to the numerator and denominator of an 'mpq_t'.

   Note that if an assignment to the numerator and/or denominator could
take an 'mpq_t' out of the canonical form described at the start of this
chapter (*note Rational Number Functions::) then 'mpq_canonicalize' must
be called before any other 'mpq' functions are applied to that 'mpq_t'.

 -- Macro: mpz_t mpq_numref (mpq_t OP)
 -- Macro: mpz_t mpq_denref (mpq_t OP)
     Return a reference to the numerator and denominator of OP,
     respectively.  The 'mpz' functions can be used on the result of
     these macros.

 -- Function: void mpq_get_num (mpz_t NUMERATOR, mpq_t RATIONAL)
 -- Function: void mpq_get_den (mpz_t DENOMINATOR, mpq_t RATIONAL)
 -- Function: void mpq_set_num (mpq_t RATIONAL, mpz_t NUMERATOR)
 -- Function: void mpq_set_den (mpq_t RATIONAL, mpz_t DENOMINATOR)
     Get or set the numerator or denominator of a rational.  These
     functions are equivalent to calling 'mpz_set' with an appropriate
     'mpq_numref' or 'mpq_denref'.  Direct use of 'mpq_numref' or
     'mpq_denref' is recommended instead of these functions.


File: mpir.info,  Node: I/O of Rationals,  Prev: Applying Integer Functions,  Up: Rational Number Functions

6.6 Input and Output Functions
==============================

When using any of these functions, it's a good idea to include 'stdio.h'
before 'mpir.h', since that will allow 'mpir.h' to define prototypes for
these functions.

   Passing a 'NULL' pointer for a STREAM argument to any of these
functions will make them read from 'stdin' and write to 'stdout',
respectively.

 -- Function: size_t mpq_out_str (FILE *STREAM, int BASE, mpq_t OP)
     Output OP on stdio stream STREAM, as a string of digits in base
     BASE.  The base may vary from 2 to 36.  Output is in the form
     'num/den' or if the denominator is 1 then just 'num'.

     Return the number of bytes written, or if an error occurred, return
     0.

 -- Function: size_t mpq_inp_str (mpq_t ROP, FILE *STREAM, int BASE)
     Read a string of digits from STREAM and convert them to a rational
     in ROP.  Any initial white-space characters are read and discarded.
     Return the number of characters read (including white space), or 0
     if a rational could not be read.

     The input can be a fraction like '17/63' or just an integer like
     '123'.  Reading stops at the first character not in this form, and
     white space is not permitted within the string.  If the input might
     not be in canonical form, then 'mpq_canonicalize' must be called
     (*note Rational Number Functions::).

     The BASE can be between 2 and 36, or can be 0 in which case the
     leading characters of the string determine the base, '0x' or '0X'
     for hexadecimal, '0' for octal, or decimal otherwise.  The leading
     characters are examined separately for the numerator and
     denominator of a fraction, so for instance '0x10/11' is 16/11,
     whereas '0x10/0x11' is 16/17.


File: mpir.info,  Node: Floating-point Functions,  Next: Low-level Functions,  Prev: Rational Number Functions,  Up: Top

7 Floating-point Functions
**************************

MPIR floating point numbers are stored in objects of type 'mpf_t' and
functions operating on them have an 'mpf_' prefix.

   The mantissa of each float has a user-selectable precision, limited
only by available memory.  Each variable has its own precision, and that
can be increased or decreased at any time.

   The exponent of each float is a fixed precision, one machine word on
most systems.  In the current implementation the exponent is a count of
limbs, so for example on a 32-bit system this means a range of roughly
2^-68719476768 to 2^68719476736, or on a 64-bit system this will be
greater.  Note however 'mpf_get_str' can only return an exponent which
fits an 'mp_exp_t' and currently 'mpf_set_str' doesn't accept exponents
bigger than a 'mpir_si'.

   Each variable keeps a size for the mantissa data actually in use.
This means that if a float is exactly represented in only a few bits
then only those bits will be used in a calculation, even if the selected
precision is high.

   All calculations are performed to the precision of the destination
variable.  Each function is defined to calculate with "infinite
precision" followed by a truncation to the destination precision, but of
course the work done is only what's needed to determine a result under
that definition.

   The precision selected for a variable is a minimum value, MPIR may
increase it a little to facilitate efficient calculation.  Currently
this means rounding up to a whole limb, and then sometimes having a
further partial limb, depending on the high limb of the mantissa.  But
applications shouldn't be concerned by such details.

   The mantissa in stored in binary, as might be imagined from the fact
precisions are expressed in bits.  One consequence of this is that
decimal fractions like 0.1 cannot be represented exactly.  The same is
true of plain IEEE 'double' floats.  This makes both highly unsuitable
for calculations involving money or other values that should be exact
decimal fractions.  (Suitably scaled integers, or perhaps rationals, are
better choices.)

   'mpf' functions and variables have no special notion of infinity or
not-a-number, and applications must take care not to overflow the
exponent or results will be unpredictable.  This might change in a
future release.

   Note that the 'mpf' functions are _not_ intended as a smooth
extension to IEEE P754 arithmetic.  In particular results obtained on
one computer often differ from the results on a computer with a
different word size.

* Menu:

* Initializing Floats::
* Assigning Floats::
* Simultaneous Float Init & Assign::
* Converting Floats::
* Float Arithmetic::
* Float Comparison::
* I/O of Floats::
* Miscellaneous Float Functions::


File: mpir.info,  Node: Initializing Floats,  Next: Assigning Floats,  Prev: Floating-point Functions,  Up: Floating-point Functions

7.1 Initialization Functions
============================

 -- Function: void mpf_set_default_prec (mp_bitcnt_t PREC)
     Set the default precision to be *at least* PREC bits.  All
     subsequent calls to 'mpf_init' will use this precision, but
     previously initialized variables are unaffected.

 -- Function: mp_bitcnt_t mpf_get_default_prec (void)
     Return the default precision actually used.

   An 'mpf_t' object must be initialized before storing the first value
in it.  The functions 'mpf_init' and 'mpf_init2' are used for that
purpose.

 -- Function: void mpf_init (mpf_t X)
     Initialize X to 0.  Normally, a variable should be initialized once
     only or at least be cleared, using 'mpf_clear', between
     initializations.  The precision of X is undefined unless a default
     precision has already been established by a call to
     'mpf_set_default_prec'.

 -- Function: void mpf_init2 (mpf_t X, mp_bitcnt_t PREC)
     Initialize X to 0 and set its precision to be *at least* PREC bits.
     Normally, a variable should be initialized once only or at least be
     cleared, using 'mpf_clear', between initializations.

 -- Function: void mpf_inits (mpf_t X, ...)
     Initialize a NULL-terminated list of 'mpf_t' variables, and set
     their values to 0.  The precision of the initialized variables is
     undefined unless a default precision has already been established
     by a call to 'mpf_set_default_prec'.

 -- Function: void mpf_clear (mpf_t X)
     Free the space occupied by X.  Make sure to call this function for
     all 'mpf_t' variables when you are done with them.

 -- Function: void mpf_clears (mpf_t X, ...)
     Free the space occupied by a NULL-terminated list of 'mpf_t'
     variables.

   Here is an example on how to initialize floating-point variables:
     {
       mpf_t x, y;
       mpf_init (x);           /* use default precision */
       mpf_init2 (y, 256);     /* precision _at least_ 256 bits */
       ...
       /* Unless the program is about to exit, do ... */
       mpf_clear (x);
       mpf_clear (y);
     }

   The following three functions are useful for changing the precision
during a calculation.  A typical use would be for adjusting the
precision gradually in iterative algorithms like Newton-Raphson, making
the computation precision closely match the actual accurate part of the
numbers.

 -- Function: mp_bitcnt_t mpf_get_prec (mpf_t OP)
     Return the current precision of OP, in bits.

 -- Function: void mpf_set_prec (mpf_t ROP, mp_bitcnt_t PREC)
     Set the precision of ROP to be *at least* PREC bits.  The value in
     ROP will be truncated to the new precision.

     This function requires a call to 'realloc', and so should not be
     used in a tight loop.

 -- Function: void mpf_set_prec_raw (mpf_t ROP, mp_bitcnt_t PREC)
     Set the precision of ROP to be *at least* PREC bits, without
     changing the memory allocated.

     PREC must be no more than the allocated precision for ROP, that
     being the precision when ROP was initialized, or in the most recent
     'mpf_set_prec'.

     The value in ROP is unchanged, and in particular if it had a higher
     precision than PREC it will retain that higher precision.  New
     values written to ROP will use the new PREC.

     Before calling 'mpf_clear' or the full 'mpf_set_prec', another
     'mpf_set_prec_raw' call must be made to restore ROP to its original
     allocated precision.  Failing to do so will have unpredictable
     results.

     'mpf_get_prec' can be used before 'mpf_set_prec_raw' to get the
     original allocated precision.  After 'mpf_set_prec_raw' it reflects
     the PREC value set.

     'mpf_set_prec_raw' is an efficient way to use an 'mpf_t' variable
     at different precisions during a calculation, perhaps to gradually
     increase precision in an iteration, or just to use various
     different precisions for different purposes during a calculation.


File: mpir.info,  Node: Assigning Floats,  Next: Simultaneous Float Init & Assign,  Prev: Initializing Floats,  Up: Floating-point Functions

7.2 Assignment Functions
========================

These functions assign new values to already initialized floats (*note
Initializing Floats::).

 -- Function: void mpf_set (mpf_t ROP, mpf_t OP)
 -- Function: void mpf_set_ui (mpf_t ROP, mpir_ui OP)
 -- Function: void mpf_set_si (mpf_t ROP, mpir_si OP)
 -- Function: void mpf_set_d (mpf_t ROP, double OP)
 -- Function: void mpf_set_z (mpf_t ROP, mpz_t OP)
 -- Function: void mpf_set_q (mpf_t ROP, mpq_t OP)
     Set the value of ROP from OP.

 -- Function: int mpf_set_str (mpf_t ROP, char *STR, int BASE)
     Set the value of ROP from the string in STR.  The string is of the
     form 'M@N' or, if the base is 10 or less, alternatively 'MeN'.  'M'
     is the mantissa and 'N' is the exponent.  The mantissa is always in
     the specified base.  The exponent is either in the specified base
     or, if BASE is negative, in decimal.  The decimal point expected is
     taken from the current locale, on systems providing 'localeconv'.

     The argument BASE may be in the ranges 2 to 62, or -62 to -2.
     Negative values are used to specify that the exponent is in
     decimal.

     For bases up to 36, case is ignored; upper-case and lower-case
     letters have the same value; for bases 37 to 62, upper-case letter
     represent the usual 10..35 while lower-case letter represent
     36..61.

     Unlike the corresponding 'mpz' function, the base will not be
     determined from the leading characters of the string if BASE is 0.
     This is so that numbers like '0.23' are not interpreted as octal.

     White space is allowed in the string, and is simply ignored.  [This
     is not really true; white-space is ignored in the beginning of the
     string and within the mantissa, but not in other places, such as
     after a minus sign or in the exponent.  We are considering changing
     the definition of this function, making it fail when there is any
     white-space in the input, since that makes a lot of sense.  Please
     tell us your opinion about this change.  Do you really want it to
     accept "3 14" as meaning 314 as it does now?]

     This function returns 0 if the entire string is a valid number in
     base BASE.  Otherwise it returns -1.

 -- Function: void mpf_swap (mpf_t ROP1, mpf_t ROP2)
     Swap ROP1 and ROP2 efficiently.  Both the values and the precisions
     of the two variables are swapped.


File: mpir.info,  Node: Simultaneous Float Init & Assign,  Next: Converting Floats,  Prev: Assigning Floats,  Up: Floating-point Functions

7.3 Combined Initialization and Assignment Functions
====================================================

For convenience, MPIR provides a parallel series of initialize-and-set
functions which initialize the output and then store the value there.
These functions' names have the form 'mpf_init_set...'

   Once the float has been initialized by any of the 'mpf_init_set...'
functions, it can be used as the source or destination operand for the
ordinary float functions.  Don't use an initialize-and-set function on a
variable already initialized!

 -- Function: void mpf_init_set (mpf_t ROP, mpf_t OP)
 -- Function: void mpf_init_set_ui (mpf_t ROP, mpir_ui OP)
 -- Function: void mpf_init_set_si (mpf_t ROP, mpir_si OP)
 -- Function: void mpf_init_set_d (mpf_t ROP, double OP)
     Initialize ROP and set its value from OP.

     The precision of ROP will be taken from the active default
     precision, as set by 'mpf_set_default_prec'.

 -- Function: int mpf_init_set_str (mpf_t ROP, char *STR, int BASE)
     Initialize ROP and set its value from the string in STR.  See
     'mpf_set_str' above for details on the assignment operation.

     Note that ROP is initialized even if an error occurs.  (I.e., you
     have to call 'mpf_clear' for it.)

     The precision of ROP will be taken from the active default
     precision, as set by 'mpf_set_default_prec'.


File: mpir.info,  Node: Converting Floats,  Next: Float Arithmetic,  Prev: Simultaneous Float Init & Assign,  Up: Floating-point Functions

7.4 Conversion Functions
========================

 -- Function: double mpf_get_d (mpf_t OP)
     Convert OP to a 'double', truncating if necessary (ie. rounding
     towards zero).

     If the exponent in OP is too big or too small to fit a 'double'
     then the result is system dependent.  For too big an infinity is
     returned when available.  For too small 0.0 is normally returned.
     Hardware overflow, underflow and denorm traps may or may not occur.

 -- Function: double mpf_get_d_2exp (mpir_si *EXP, mpf_t OP)
     Convert OP to a 'double', truncating if necessary (ie. rounding
     towards zero), and with an exponent returned separately.

     The return value is in the range 0.5<=abs(D)<1 and the exponent is
     stored to '*EXP'.  D * 2^EXP is the (truncated) OP value.  If OP is
     zero, the return is 0.0 and 0 is stored to '*EXP'.

     This is similar to the standard C 'frexp' function (*note
     (libc)Normalization Functions::).

 -- Function: mpir_si mpf_get_si (mpf_t OP)
 -- Function: mpir_ui mpf_get_ui (mpf_t OP)
     Convert OP to a 'mpir_si' or 'mpir_ui', truncating any fraction
     part.  If OP is too big for the return type, the result is
     undefined.

     See also 'mpf_fits_slong_p' and 'mpf_fits_ulong_p' (*note
     Miscellaneous Float Functions::).

 -- Function: char * mpf_get_str (char *STR, mp_exp_t *EXPPTR, int BASE,
          size_t N_DIGITS, mpf_t OP)
     Convert OP to a string of digits in base BASE.  BASE can vary from
     2 to 362 or from -2 to -36.  Up to N_DIGITS digits will be
     generated.  Trailing zeros are not returned.  No more digits than
     can be accurately represented by OP are ever generated.  If
     N_DIGITS is 0 then that accurate maximum number of digits are
     generated.

     For BASE in the range 2..36, digits and lower-case letters are
     used; for -2..-36, digits and upper-case letters are used; for
     37..62, digits, upper-case letters, and lower-case letters (in that
     significance order) are used.

     If STR is 'NULL', the result string is allocated using the current
     allocation function (*note Custom Allocation::).  The block will be
     'strlen(str)+1' bytes, that being exactly enough for the string and
     null-terminator.

     If STR is not 'NULL', it should point to a block of N_DIGITS + 2
     bytes, that being enough for the mantissa, a possible minus sign,
     and a null-terminator.  When N_DIGITS is 0 to get all significant
     digits, an application won't be able to know the space required,
     and STR should be 'NULL' in that case.

     The generated string is a fraction, with an implicit radix point
     immediately to the left of the first digit.  The applicable
     exponent is written through the EXPPTR pointer.  For example, the
     number 3.1416 would be returned as string "31416" and exponent 1.

     When OP is zero, an empty string is produced and the exponent
     returned is 0.

     A pointer to the result string is returned, being either the
     allocated block or the given STR.


File: mpir.info,  Node: Float Arithmetic,  Next: Float Comparison,  Prev: Converting Floats,  Up: Floating-point Functions

7.5 Arithmetic Functions
========================

 -- Function: void mpf_add (mpf_t ROP, mpf_t OP1, mpf_t OP2)
 -- Function: void mpf_add_ui (mpf_t ROP, mpf_t OP1, mpir_ui OP2)
     Set ROP to OP1 + OP2.

 -- Function: void mpf_sub (mpf_t ROP, mpf_t OP1, mpf_t OP2)
 -- Function: void mpf_ui_sub (mpf_t ROP, mpir_ui OP1, mpf_t OP2)
 -- Function: void mpf_sub_ui (mpf_t ROP, mpf_t OP1, mpir_ui OP2)
     Set ROP to OP1 - OP2.

 -- Function: void mpf_mul (mpf_t ROP, mpf_t OP1, mpf_t OP2)
 -- Function: void mpf_mul_ui (mpf_t ROP, mpf_t OP1, mpir_ui OP2)
     Set ROP to OP1 times OP2.

   Division is undefined if the divisor is zero, and passing a zero
divisor to the divide functions will make these functions intentionally
divide by zero.  This lets the user handle arithmetic exceptions in
these functions in the same manner as other arithmetic exceptions.

 -- Function: void mpf_div (mpf_t ROP, mpf_t OP1, mpf_t OP2)
 -- Function: void mpf_ui_div (mpf_t ROP, mpir_ui OP1, mpf_t OP2)
 -- Function: void mpf_div_ui (mpf_t ROP, mpf_t OP1, mpir_ui OP2)
     Set ROP to OP1/OP2.

 -- Function: void mpf_sqrt (mpf_t ROP, mpf_t OP)
 -- Function: void mpf_sqrt_ui (mpf_t ROP, mpir_ui OP)
     Set ROP to the square root of OP.

 -- Function: void mpf_pow_ui (mpf_t ROP, mpf_t OP1, mpir_ui OP2)
     Set ROP to OP1 raised to the power OP2.

 -- Function: void mpf_neg (mpf_t ROP, mpf_t OP)
     Set ROP to -OP.

 -- Function: void mpf_abs (mpf_t ROP, mpf_t OP)
     Set ROP to the absolute value of OP.

 -- Function: void mpf_mul_2exp (mpf_t ROP, mpf_t OP1, mp_bitcnt_t OP2)
     Set ROP to OP1 times 2 raised to OP2.

 -- Function: void mpf_div_2exp (mpf_t ROP, mpf_t OP1, mp_bitcnt_t OP2)
     Set ROP to OP1 divided by 2 raised to OP2.


File: mpir.info,  Node: Float Comparison,  Next: I/O of Floats,  Prev: Float Arithmetic,  Up: Floating-point Functions

7.6 Comparison Functions
========================

 -- Function: int mpf_cmp (mpf_t OP1, mpf_t OP2)
 -- Function: int mpf_cmp_d (mpf_t OP1, double OP2)
 -- Function: int mpf_cmp_ui (mpf_t OP1, mpir_ui OP2)
 -- Function: int mpf_cmp_si (mpf_t OP1, mpir_si OP2)
     Compare OP1 and OP2.  Return a positive value if OP1 > OP2, zero if
     OP1 = OP2, and a negative value if OP1 < OP2.

     'mpf_cmp_d' can be called with an infinity, but results are
     undefined for a NaN.

 -- Function: int mpf_eq (mpf_t OP1, mpf_t OP2, mp_bitcnt_t op3)
     Return non-zero if the first OP3 bits of OP1 and OP2 are equal,
     zero otherwise.  I.e., test if OP1 and OP2 are approximately equal.

     In the future values like 1000 and 0111 may be considered the same
     to 3 bits (on the basis that their difference is that small).

 -- Function: void mpf_reldiff (mpf_t ROP, mpf_t OP1, mpf_t OP2)
     Compute the relative difference between OP1 and OP2 and store the
     result in ROP.  This is abs(OP1-OP2)/OP1.

 -- Macro: int mpf_sgn (mpf_t OP)
     Return +1 if OP > 0, 0 if OP = 0, and -1 if OP < 0.

     This function is actually implemented as a macro.  It evaluates its
     arguments multiple times.


File: mpir.info,  Node: I/O of Floats,  Next: Miscellaneous Float Functions,  Prev: Float Comparison,  Up: Floating-point Functions

7.7 Input and Output Functions
==============================

Functions that perform input from a stdio stream, and functions that
output to a stdio stream.  Passing a 'NULL' pointer for a STREAM
argument to any of these functions will make them read from 'stdin' and
write to 'stdout', respectively.

   When using any of these functions, it is a good idea to include
'stdio.h' before 'mpir.h', since that will allow 'mpir.h' to define
prototypes for these functions.

 -- Function: size_t mpf_out_str (FILE *STREAM, int BASE, size_t
          N_DIGITS, mpf_t OP)
     Print OP to STREAM, as a string of digits.  Return the number of
     bytes written, or if an error occurred, return 0.

     The mantissa is prefixed with an '0.' and is in the given BASE,
     which may vary from 2 to 36.  An exponent then printed, separated
     by an 'e', or if BASE is greater than 10 then by an '@'.  The
     exponent is always in decimal.  The decimal point follows the
     current locale, on systems providing 'localeconv'.

     For BASE in the range 2..36, digits and lower-case letters are
     used; for -2..-36, digits and upper-case letters are used; for
     37..62, digits, upper-case letters, and lower-case letters (in that
     significance order) are used.

     Up to N_DIGITS will be printed from the mantissa, except that no
     more digits than are accurately representable by OP will be
     printed.  N_DIGITS can be 0 to select that accurate maximum.

 -- Function: size_t mpf_inp_str (mpf_t ROP, FILE *STREAM, int BASE)
     Read a string in base BASE from STREAM, and put the read float in
     ROP.  The string is of the form 'M@N' or, if the base is 10 or
     less, alternatively 'MeN'.  'M' is the mantissa and 'N' is the
     exponent.  The mantissa is always in the specified base.  The
     exponent is either in the specified base or, if BASE is negative,
     in decimal.  The decimal point expected is taken from the current
     locale, on systems providing 'localeconv'.

     The argument BASE may be in the ranges 2 to 36, or -36 to -2.
     Negative values are used to specify that the exponent is in
     decimal.

     Unlike the corresponding 'mpz' function, the base will not be
     determined from the leading characters of the string if BASE is 0.
     This is so that numbers like '0.23' are not interpreted as octal.

     Return the number of bytes read, or if an error occurred, return 0.


File: mpir.info,  Node: Miscellaneous Float Functions,  Prev: I/O of Floats,  Up: Floating-point Functions

7.8 Miscellaneous Functions
===========================

 -- Function: void mpf_ceil (mpf_t ROP, mpf_t OP)
 -- Function: void mpf_floor (mpf_t ROP, mpf_t OP)
 -- Function: void mpf_trunc (mpf_t ROP, mpf_t OP)
     Set ROP to OP rounded to an integer.  'mpf_ceil' rounds to the next
     higher integer, 'mpf_floor' to the next lower, and 'mpf_trunc' to
     the integer towards zero.

 -- Function: int mpf_integer_p (mpf_t OP)
     Return non-zero if OP is an integer.

 -- Function: int mpf_fits_ulong_p (mpf_t OP)
 -- Function: int mpf_fits_slong_p (mpf_t OP)
 -- Function: int mpf_fits_uint_p (mpf_t OP)
 -- Function: int mpf_fits_sint_p (mpf_t OP)
 -- Function: int mpf_fits_ushort_p (mpf_t OP)
 -- Function: int mpf_fits_sshort_p (mpf_t OP)
     Return non-zero if OP would fit in the respective C data type, when
     truncated to an integer.

 -- Function: void mpf_urandomb (mpf_t ROP, gmp_randstate_t STATE,
          mp_bitcnt_t NBITS)
     Generate a uniformly distributed random float in ROP, such that 0
     <= ROP < 1, with NBITS significant bits in the mantissa.

     The variable STATE must be initialized by calling one of the
     'gmp_randinit' functions (*note Random State Initialization::)
     before invoking this function.

 -- Function: void mpf_rrandomb (mpf_t ROP, gmp_randstate_t STATE,
          mp_size_t MAX_SIZE, mp_exp_t EXP)
     Generate a random float of at most MAX_SIZE limbs, with long
     strings of zeros and ones in the binary representation.  The
     exponent of the number is in the interval -EXP to EXP (in limbs).
     This function is useful for testing functions and algorithms, since
     these kind of random numbers have proven to be more likely to
     trigger corner-case bugs.  Negative random numbers are generated
     when MAX_SIZE is negative.

     *This interface is preliminary.  It might change incompatibly in
     future revisions.*

 -- Function: void mpf_random2 (mpf_t ROP, mp_size_t MAX_SIZE, mp_exp_t
          EXP)
     Generate a random float of at most MAX_SIZE limbs, with long
     strings of zeros and ones in the binary representation.  The
     exponent of the number is in the interval -EXP to EXP (in limbs).
     This function is useful for testing functions and algorithms, since
     these kind of random numbers have proven to be more likely to
     trigger corner-case bugs.  Negative random numbers are generated
     when MAX_SIZE is negative.

     *This function is obsolete.  It will disappear from future MPIR
     releases.*


File: mpir.info,  Node: Low-level Functions,  Next: Random Number Functions,  Prev: Floating-point Functions,  Up: Top

8 Low-level Functions
*********************

This chapter describes low-level MPIR functions, used to implement the
high-level MPIR functions, but also intended for time-critical user
code.

   These functions start with the prefix 'mpn_'.

   The 'mpn' functions are designed to be as fast as possible, *not* to
provide a coherent calling interface.  The different functions have
somewhat similar interfaces, but there are variations that make them
hard to use.  These functions do as little as possible apart from the
real multiple precision computation, so that no time is spent on things
that not all callers need.

   A source operand is specified by a pointer to the least significant
limb and a limb count.  A destination operand is specified by just a
pointer.  It is the responsibility of the caller to ensure that the
destination has enough space for storing the result.

   With this way of specifying operands, it is possible to perform
computations on subranges of an argument, and store the result into a
subrange of a destination.

   A common requirement for all functions is that each source area needs
at least one limb.  No size argument may be zero.  Unless otherwise
stated, in-place operations are allowed where source and destination are
the same, but not where they only partly overlap.

   The 'mpn' functions are the base for the implementation of the
'mpz_', 'mpf_', and 'mpq_' functions.

   This example adds the number beginning at S1P and the number
beginning at S2P and writes the sum at DESTP.  All areas have N limbs.

     cy = mpn_add_n (destp, s1p, s2p, n)

   It should be noted that the 'mpn' functions make no attempt to
identify high or low zero limbs on their operands, or other special
forms.  On random data such cases will be unlikely and it'd be wasteful
for every function to check every time.  An application knowing
something about its data can take steps to trim or perhaps split its
calculations.


In the notation used below, a source operand is identified by the
pointer to the least significant limb, and the limb count in braces.
For example, {S1P, S1N}.

 -- Function: mp_limb_t mpn_add_n (mp_limb_t *RP, const mp_limb_t *S1P,
          const mp_limb_t *S2P, mp_size_t N)
     Add {S1P, N} and {S2P, N}, and write the N least significant limbs
     of the result to RP.  Return carry, either 0 or 1.

     This is the lowest-level function for addition.  It is the
     preferred function for addition, since it is written in assembly
     for most CPUs.  For addition of a variable to itself (i.e., S1P
     equals S2P, use 'mpn_lshift' with a count of 1 for optimal speed.

 -- Function: mp_limb_t mpn_add_1 (mp_limb_t *RP, const mp_limb_t *S1P,
          mp_size_t N, mp_limb_t S2LIMB)
     Add {S1P, N} and S2LIMB, and write the N least significant limbs of
     the result to RP.  Return carry, either 0 or 1.

 -- Function: mp_limb_t mpn_add (mp_limb_t *RP, const mp_limb_t *S1P,
          mp_size_t S1N, const mp_limb_t *S2P, mp_size_t S2N)
     Add {S1P, S1N} and {S2P, S2N}, and write the S1N least significant
     limbs of the result to RP.  Return carry, either 0 or 1.

     This function requires that S1N is greater than or equal to S2N.

 -- Function: mp_limb_t mpn_sub_n (mp_limb_t *RP, const mp_limb_t *S1P,
          const mp_limb_t *S2P, mp_size_t N)
     Subtract {S2P, N} from {S1P, N}, and write the N least significant
     limbs of the result to RP.  Return borrow, either 0 or 1.

     This is the lowest-level function for subtraction.  It is the
     preferred function for subtraction, since it is written in assembly
     for most CPUs.

 -- Function: mp_limb_t mpn_sub_1 (mp_limb_t *RP, const mp_limb_t *S1P,
          mp_size_t N, mp_limb_t S2LIMB)
     Subtract S2LIMB from {S1P, N}, and write the N least significant
     limbs of the result to RP.  Return borrow, either 0 or 1.

 -- Function: mp_limb_t mpn_sub (mp_limb_t *RP, const mp_limb_t *S1P,
          mp_size_t S1N, const mp_limb_t *S2P, mp_size_t S2N)
     Subtract {S2P, S2N} from {S1P, S1N}, and write the S1N least
     significant limbs of the result to RP.  Return borrow, either 0 or
     1.

     This function requires that S1N is greater than or equal to S2N.

 -- Function: void mpn_neg (mp_limb_t *RP, const mp_limb_t *SP,
          mp_size_t N)
     Perform the negation of {SP, N}, and write the result to {RP, N}.
     Return carry-out.

 -- Function: void mpn_mul_n (mp_limb_t *RP, const mp_limb_t *S1P, const
          mp_limb_t *S2P, mp_size_t N)
     Multiply {S1P, N} and {S2P, N}, and write the 2*N-limb result to
     RP.

     The destination has to have space for 2*N limbs, even if the
     product's most significant limb is zero.  No overlap is permitted
     between the destination and either source.

     If the input operands are the same, 'mpn_sqr' will generally be
     faster.

 -- Function: mp_limb_t mpn_mul_1 (mp_limb_t *RP, const mp_limb_t *S1P,
          mp_size_t N, mp_limb_t S2LIMB)
     Multiply {S1P, N} by S2LIMB, and write the N least significant
     limbs of the product to RP.  Return the most significant limb of
     the product.  {S1P, N} and {RP, N} are allowed to overlap provided
     RP <= S1P.

     This is a low-level function that is a building block for general
     multiplication as well as other operations in MPIR.  It is written
     in assembly for most CPUs.

     Don't call this function if S2LIMB is a power of 2; use
     'mpn_lshift' with a count equal to the logarithm of S2LIMB instead,
     for optimal speed.

 -- Function: mp_limb_t mpn_addmul_1 (mp_limb_t *RP, const mp_limb_t
          *S1P, mp_size_t N, mp_limb_t S2LIMB)
     Multiply {S1P, N} and S2LIMB, and add the N least significant limbs
     of the product to {RP, N} and write the result to RP.  Return the
     most significant limb of the product, plus carry-out from the
     addition.

     This is a low-level function that is a building block for general
     multiplication as well as other operations in MPIR.  It is written
     in assembly for most CPUs.

 -- Function: mp_limb_t mpn_submul_1 (mp_limb_t *RP, const mp_limb_t
          *S1P, mp_size_t N, mp_limb_t S2LIMB)
     Multiply {S1P, N} and S2LIMB, and subtract the N least significant
     limbs of the product from {RP, N} and write the result to RP.
     Return the most significant limb of the product, minus borrow-out
     from the subtraction.

     This is a low-level function that is a building block for general
     multiplication and division as well as other operations in MPIR.
     It is written in assembly for most CPUs.

 -- Function: mp_limb_t mpn_mul (mp_limb_t *RP, const mp_limb_t *S1P,
          mp_size_t S1N, const mp_limb_t *S2P, mp_size_t S2N)
     Multiply {S1P, S1N} and {S2P, S2N}, and write the result to RP.
     Return the most significant limb of the result.

     The destination has to have space for S1N + S2N limbs, even if the
     result might be one limb smaller.

     This function requires that S1N is greater than or equal to S2N.
     The destination must be distinct from both input operands.

 -- Function: void mpn_sqr (mp_limb_t *RP, const mp_limb_t *S1P,
          mp_size_t N)
     Compute the square of {S1P, N} and write the 2*N-limb result to RP.

     The destination has to have space for 2*N limbs, even if the
     result's most significant limb is zero.  No overlap is permitted
     between the destination and the source.

 -- Function: void mpn_tdiv_qr (mp_limb_t *QP, mp_limb_t *RP, mp_size_t
          QXN, const mp_limb_t *NP, mp_size_t NN, const mp_limb_t *DP,
          mp_size_t DN)
     Divide {NP, NN} by {DP, DN} and put the quotient at {QP, NN-DN+1}
     and the remainder at {RP, DN}.  The quotient is rounded towards 0.

     No overlap is permitted between arguments.  NN must be greater than
     or equal to DN.  The most significant limb of DP must be non-zero.
     The QXN operand must be zero.

 -- Function: mp_limb_t mpn_divrem (mp_limb_t *R1P, mp_size_t QXN,
          mp_limb_t *RS2P, mp_size_t RS2N, const mp_limb_t *S3P,
          mp_size_t S3N)
     [This function is obsolete.  Please call 'mpn_tdiv_qr' instead for
     best performance.]

     Divide {RS2P, RS2N} by {S3P, S3N}, and write the quotient at R1P,
     with the exception of the most significant limb, which is returned.
     The remainder replaces the dividend at RS2P; it will be S3N limbs
     long (i.e., as many limbs as the divisor).

     In addition to an integer quotient, QXN fraction limbs are
     developed, and stored after the integral limbs.  For most usages,
     QXN will be zero.

     It is required that RS2N is greater than or equal to S3N.  It is
     required that the most significant bit of the divisor is set.

     If the quotient is not needed, pass RS2P + S3N as R1P.  Aside from
     that special case, no overlap between arguments is permitted.

     Return the most significant limb of the quotient, either 0 or 1.

     The area at R1P needs to be RS2N - S3N + QXN limbs large.

 -- Function: mp_limb_t mpn_divrem_1 (mp_limb_t *R1P, mp_size_t QXN,
          mp_limb_t *S2P, mp_size_t S2N, mp_limb_t S3LIMB)
 -- Macro: mp_limb_t mpn_divmod_1 (mp_limb_t *R1P, mp_limb_t *S2P,
          mp_size_t S2N, mp_limb_t S3LIMB)
     Divide {S2P, S2N} by S3LIMB, and write the quotient at R1P.  Return
     the remainder.

     The integer quotient is written to {R1P+QXN, S2N} and in addition
     QXN fraction limbs are developed and written to {R1P, QXN}.  Either
     or both S2N and QXN can be zero.  For most usages, QXN will be
     zero.

     'mpn_divmod_1' exists for upward source compatibility and is simply
     a macro calling 'mpn_divrem_1' with a QXN of 0.

     The areas at R1P and S2P have to be identical or completely
     separate, not partially overlapping.

 -- Macro: mp_limb_t mpn_divexact_by3 (mp_limb_t *RP, mp_limb_t *SP,
          mp_size_t N)
 -- Function: mp_limb_t mpn_divexact_by3c (mp_limb_t *RP, mp_limb_t *SP,
          mp_size_t N, mp_limb_t CARRY)
     Divide {SP, N} by 3, expecting it to divide exactly, and writing
     the result to {RP, N}.  If 3 divides exactly, the return value is
     zero and the result is the quotient.  If not, the return value is
     non-zero and the result won't be anything useful.

     'mpn_divexact_by3c' takes an initial carry parameter, which can be
     the return value from a previous call, so a large calculation can
     be done piece by piece from low to high.  'mpn_divexact_by3' is
     simply a macro calling 'mpn_divexact_by3c' with a 0 carry
     parameter.

     These routines use a multiply-by-inverse and will be faster than
     'mpn_divrem_1' on CPUs with fast multiplication but slow division.

     The source a, result q, size n, initial carry i, and return value c
     satisfy c*b^n + a-i = 3*q, where b=2^GMP_NUMB_BITS.  The return c
     is always 0, 1 or 2, and the initial carry i must also be 0, 1 or 2
     (these are both borrows really).  When c=0 clearly q=(a-i)/3.  When
     c!=0, the remainder (a-i) mod 3 is given by 3-c, because b == 1 mod
     3 (when 'mp_bits_per_limb' is even, which is always so currently).

 -- Function: mp_limb_t mpn_mod_1 (mp_limb_t *S1P, mp_size_t S1N,
          mp_limb_t S2LIMB)
     Divide {S1P, S1N} by S2LIMB, and return the remainder.  S1N can be
     zero.

 -- Function: mp_limb_t mpn_lshift (mp_limb_t *RP, const mp_limb_t *SP,
          mp_size_t N, unsigned int COUNT)
     Shift {SP, N} left by COUNT bits, and write the result to {RP, N}.
     The bits shifted out at the left are returned in the least
     significant COUNT bits of the return value (the rest of the return
     value is zero).

     COUNT must be in the range 1 to mp_bits_per_limb-1.  The regions
     {SP, N} and {RP, N} may overlap, provided RP >= SP.

     This function is written in assembly for most CPUs.

 -- Function: mp_limb_t mpn_rshift (mp_limb_t *RP, const mp_limb_t *SP,
          mp_size_t N, unsigned int COUNT)
     Shift {SP, N} right by COUNT bits, and write the result to {RP, N}.
     The bits shifted out at the right are returned in the most
     significant COUNT bits of the return value (the rest of the return
     value is zero).

     COUNT must be in the range 1 to mp_bits_per_limb-1.  The regions
     {SP, N} and {RP, N} may overlap, provided RP <= SP.

     This function is written in assembly for most CPUs.

 -- Function: int mpn_cmp (const mp_limb_t *S1P, const mp_limb_t *S2P,
          mp_size_t N)
     Compare {S1P, N} and {S2P, N} and return a positive value if S1 >
     S2, 0 if they are equal, or a negative value if S1 < S2.

 -- Function: mp_size_t mpn_gcd (mp_limb_t *RP, mp_limb_t *S1P,
          mp_size_t S1N, mp_limb_t *S2P, mp_size_t S2N)
     Set {RP, RETVAL} to the greatest common divisor of {S1P, S1N} and
     {S2P, S2N}.  The result can be up to S2N limbs, the return value is
     the actual number produced.  Both source operands are destroyed.

     {S1P, S1N} must have at least as many bits as {S2P, S2N}.  {S2P,
     S2N} must be odd.  Both operands must have non-zero most
     significant limbs.  No overlap is permitted between {S1P, S1N} and
     {S2P, S2N}.

 -- Function: mp_limb_t mpn_gcd_1 (const mp_limb_t *S1P, mp_size_t S1N,
          mp_limb_t S2LIMB)
     Return the greatest common divisor of {S1P, S1N} and S2LIMB.  Both
     operands must be non-zero.

 -- Function: mp_size_t mpn_gcdext (mp_limb_t *GP, mp_limb_t *SP,
          mp_size_t *SN, mp_limb_t *XP, mp_size_t XN, mp_limb_t *YP,
          mp_size_t YN)
     Let U be defined by {XP, XN} and let V be defined by {YP, YN}.

     Compute the greatest common divisor G of U and V.  Compute a
     cofactor S such that G = US + VT.  The second cofactor T is not
     computed but can easily be obtained from (G - U*S) / V (the
     division will be exact).  It is required that U >= V > 0.

     S satisfies S = 1 or abs(S) < V / (2 G).  S = 0 if and only if V
     divides U (i.e., G = V).

     Store G at GP and let the return value define its limb count.
     Store S at SP and let |*SN| define its limb count.  S can be
     negative; when this happens *SN will be negative.  The areas at GP
     and SP should each have room for XN+1 limbs.

     The areas {XP, XN+1} and {YP, YN+1} are destroyed (i.e. the input
     operands plus an extra limb past the end of each).

     Compatibility note: MPIR versions 1.3,2.0 and GMP versions
     4.3.0,4.3.1 defined S less strictly.  Earlier as well as later GMP
     releases define S as described here.

 -- Function: mp_size_t mpn_sqrtrem (mp_limb_t *R1P, mp_limb_t *R2P,
          const mp_limb_t *SP, mp_size_t N)
     Compute the square root of {SP, N} and put the result at {R1P,
     ceil(N/2)} and the remainder at {R2P, RETVAL}.  R2P needs space for
     N limbs, but the return value indicates how many are produced.

     The most significant limb of {SP, N} must be non-zero.  The areas
     {R1P, ceil(N/2)} and {SP, N} must be completely separate.  The
     areas {R2P, N} and {SP, N} must be either identical or completely
     separate.

     If the remainder is not wanted then R2P can be 'NULL', and in this
     case the return value is zero or non-zero according to whether the
     remainder would have been zero or non-zero.

     A return value of zero indicates a perfect square.  See also
     'mpz_perfect_square_p'.

 -- Function: mp_size_t mpn_get_str (unsigned char *STR, int BASE,
          mp_limb_t *S1P, mp_size_t S1N)
     Convert {S1P, S1N} to a raw unsigned char array at STR in base
     BASE, and return the number of characters produced.  There may be
     leading zeros in the string.  The string is not in ASCII; to
     convert it to printable format, add the ASCII codes for '0' or 'A',
     depending on the base and range.  BASE can vary from 2 to 256.

     The most significant limb of the input {S1P, S1N} must be non-zero.
     The input {S1P, S1N} is clobbered, except when BASE is a power of
     2, in which case it's unchanged.

     The area at STR has to have space for the largest possible number
     represented by a S1N long limb array, plus one extra character.

 -- Function: mp_size_t mpn_set_str (mp_limb_t *RP, const unsigned char
          *STR, size_t STRSIZE, int BASE)
     Convert bytes {STR,STRSIZE} in the given BASE to limbs at RP.

     STR[0] is the most significant byte and STR[STRSIZE-1] is the least
     significant.  Each byte should be a value in the range 0 to BASE-1,
     not an ASCII character.  BASE can vary from 2 to 256.

     The return value is the number of limbs written to RP.  If the most
     significant input byte is non-zero then the high limb at RP will be
     non-zero, and only that exact number of limbs will be required
     there.

     If the most significant input byte is zero then there may be high
     zero limbs written to RP and included in the return value.

     STRSIZE must be at least 1, and no overlap is permitted between
     {STR,STRSIZE} and the result at RP.

 -- Function: mp_bitcnt_t mpn_scan0 (const mp_limb_t *S1P, imp_bitcnt_t
          BIT)
     Scan S1P from bit position BIT for the next clear bit.

     It is required that there be a clear bit within the area at S1P at
     or beyond bit position BIT, so that the function has something to
     return.

 -- Function: mp_bitcnt_t mpn_scan1 (const mp_limb_t *S1P, mp_bitcnt_t
          BIT)
     Scan S1P from bit position BIT for the next set bit.

     It is required that there be a set bit within the area at S1P at or
     beyond bit position BIT, so that the function has something to
     return.

 -- Function: void mpn_random (mp_limb_t *R1P, mp_size_t R1N)
 -- Function: void mpn_random2 (mp_limb_t *R1P, mp_size_t R1N)
     Generate a random number of length R1N and store it at R1P.  The
     most significant limb is always non-zero.  'mpn_random' generates
     uniformly distributed limb data, 'mpn_random2' generates long
     strings of zeros and ones in the binary representation.

     'mpn_random2' is intended for testing the correctness of the 'mpn'
     routines.

     *These functions are obsolete.  They will disappear from future
     MPIR releases.*

 -- Function: void mpn_urandomb (mp_limb_t *RP, gmp_randstate_t STATE,
          mpir_ui N)
     Generate a uniform random number of length N bits and store it at
     RP.

     *This function interface is preliminary and may change in the
     future.*

 -- Function: void mpn_urandomm (mp_limb_t *RP, gmp_randstate_t STATE,
          const mp_limb_t *MP, mp_size_t N)
     Generate a uniform random number modulo (MP,N) of length N limbs
     and store it at RP.

     *This function interface is preliminary and may change in the
     future.*

 -- Function: void mpn_randomb (mp_limb_t *RP, gmp_randstate_t STATE,
          mp_size_t N)
     Generate a random number of length N limbs and store it at RP.  The
     most significant limb is always non-zero.

     *This function interface is preliminary and may change in the
     future.*

 -- Function: void mpn_rrandom (mp_limb_t *RP, gmp_randstate_t STATE,
          mp_size_t N)
     Generate a random number of length N limbs and store it at RP.  The
     most significant limb is always non-zero.  Generates long strings
     of zeros and ones in the binary representation and is intended for
     testing the correctness of the 'mpn' routines.

     *This function interface is preliminary and may change in the
     future.*

 -- Function: mp_bitcnt_t mpn_popcount (const mp_limb_t *S1P, mp_size_t
          N)
     Count the number of set bits in {S1P, N}.

 -- Function: mp_bitcnt_t mpn_hamdist (const mp_limb_t *S1P, const
          mp_limb_t *S2P, mp_size_t N)
     Compute the hamming distance between {S1P, N} and {S2P, N}, which
     is the number of bit positions where the two operands have
     different bit values.

 -- Function: int mpn_perfect_square_p (const mp_limb_t *S1P, mp_size_t
          N)
     Return non-zero iff {S1P, N} is a perfect square.

 -- Function: void mpn_and_n (mp_limb_t *RP, const mp_limb_t *S1P, const
          mp_limb_t *S2P, mp_size_t N)
     Perform the bitwise logical and of {S1P, N} and {S2P, N}, and write
     the result to {RP, N}.

 -- Function: void mpn_ior_n (mp_limb_t *RP, const mp_limb_t *S1P, const
          mp_limb_t *S2P, mp_size_t N)
     Perform the bitwise logical inclusive or of {S1P, N} and {S2P, N},
     and write the result to {RP, N}.

 -- Function: void mpn_xor_n (mp_limb_t *RP, const mp_limb_t *S1P, const
          mp_limb_t *S2P, mp_size_t N)
     Perform the bitwise logical exclusive or of {S1P, N} and {S2P, N},
     and write the result to {RP, N}.

 -- Function: void mpn_andn_n (mp_limb_t *RP, const mp_limb_t *S1P,
          const mp_limb_t *S2P, mp_size_t N)
     Perform the bitwise logical and of {S1P, N} and the bitwise
     complement of {S2P, N}, and write the result to {RP, N}.

 -- Function: void mpn_iorn_n (mp_limb_t *RP, const mp_limb_t *S1P,
          const mp_limb_t *S2P, mp_size_t N)
     Perform the bitwise logical inclusive or of {S1P, N} and the
     bitwise complement of {S2P, N}, and write the result to {RP, N}.

 -- Function: void mpn_nand_n (mp_limb_t *RP, const mp_limb_t *S1P,
          const mp_limb_t *S2P, mp_size_t N)
     Perform the bitwise logical and of {S1P, N} and {S2P, N}, and write
     the bitwise complement of the result to {RP, N}.

 -- Function: void mpn_nior_n (mp_limb_t *RP, const mp_limb_t *S1P,
          const mp_limb_t *S2P, mp_size_t N)
     Perform the bitwise logical inclusive or of {S1P, N} and {S2P, N},
     and write the bitwise complement of the result to {RP, N}.

 -- Function: void mpn_xnor_n (mp_limb_t *RP, const mp_limb_t *S1P,
          const mp_limb_t *S2P, mp_size_t N)
     Perform the bitwise logical exclusive or of {S1P, N} and {S2P, N},
     and write the bitwise complement of the result to {RP, N}.

 -- Function: void mpn_com (mp_limb_t *RP, const mp_limb_t *SP,
          mp_size_t N)
     Perform the bitwise complement of {SP, N}, and write the result to
     {RP, N}.

 -- Function: void mpn_copyi (mp_limb_t *RP, const mp_limb_t *S1P,
          mp_size_t N)
     Copy from {S1P, N} to {RP, N}, increasingly.

 -- Function: void mpn_copyd (mp_limb_t *RP, const mp_limb_t *S1P,
          mp_size_t N)
     Copy from {S1P, N} to {RP, N}, decreasingly.

 -- Function: void mpn_zero (mp_limb_t *RP, mp_size_t N)
     Zero {RP, N}.


8.1 Nails
=========

*Everything in this section is highly experimental and may disappear or
be subject to incompatible changes in a future version of MPIR.*

   N.B: Nails are currently disabled and not supported in MPIR. They may
or may not return in a future version of MPIR.

   Nails are an experimental feature whereby a few bits are left unused
at the top of each 'mp_limb_t'.  This can significantly improve carry
handling on some processors.

   All the 'mpn' functions accepting limb data will expect the nail bits
to be zero on entry, and will return data with the nails similarly all
zero.  This applies both to limb vectors and to single limb arguments.

   Nails can be enabled by configuring with '--enable-nails'.  By
default the number of bits will be chosen according to what suits the
host processor, but a particular number can be selected with
'--enable-nails=N'.

   At the mpn level, a nail build is neither source nor binary
compatible with a non-nail build, strictly speaking.  But programs
acting on limbs only through the mpn functions are likely to work
equally well with either build, and judicious use of the definitions
below should make any program compatible with either build, at the
source level.

   For the higher level routines, meaning 'mpz' etc, a nail build should
be fully source and binary compatible with a non-nail build.

 -- Macro: GMP_NAIL_BITS
 -- Macro: GMP_NUMB_BITS
 -- Macro: GMP_LIMB_BITS
     'GMP_NAIL_BITS' is the number of nail bits, or 0 when nails are not
     in use.  'GMP_NUMB_BITS' is the number of data bits in a limb.
     'GMP_LIMB_BITS' is the total number of bits in an 'mp_limb_t'.  In
     all cases

          GMP_LIMB_BITS == GMP_NAIL_BITS + GMP_NUMB_BITS

 -- Macro: GMP_NAIL_MASK
 -- Macro: GMP_NUMB_MASK
     Bit masks for the nail and number parts of a limb.  'GMP_NAIL_MASK'
     is 0 when nails are not in use.

     'GMP_NAIL_MASK' is not often needed, since the nail part can be
     obtained with 'x >> GMP_NUMB_BITS', and that means one less large
     constant, which can help various RISC chips.

 -- Macro: GMP_NUMB_MAX
     The maximum value that can be stored in the number part of a limb.
     This is the same as 'GMP_NUMB_MASK', but can be used for clarity
     when doing comparisons rather than bit-wise operations.

   The term "nails" comes from finger or toe nails, which are at the
ends of a limb (arm or leg).  "numb" is short for number, but is also
how the developers felt after trying for a long time to come up with
sensible names for these things.

   In the future (the distant future most likely) a non-zero nail might
be permitted, giving non-unique representations for numbers in a limb
vector.  This would help vector processors since carries would only ever
need to propagate one or two limbs.


File: mpir.info,  Node: Random Number Functions,  Next: Formatted Output,  Prev: Low-level Functions,  Up: Top

9 Random Number Functions
*************************

Sequences of pseudo-random numbers in MPIR are generated using a
variable of type 'gmp_randstate_t', which holds an algorithm selection
and a current state.  Such a variable must be initialized by a call to
one of the 'gmp_randinit' functions, and can be seeded with one of the
'gmp_randseed' functions.

   The functions actually generating random numbers are described in
*note Integer Random Numbers::, and *note Miscellaneous Float
Functions::.

   The older style random number functions don't accept a
'gmp_randstate_t' parameter but instead share a global variable of that
type.  They use a default algorithm and are currently not seeded (though
perhaps that will change in the future).  The new functions accepting a
'gmp_randstate_t' are recommended for applications that care about
randomness.

* Menu:

* Random State Initialization::
* Random State Seeding::
* Random State Miscellaneous::


File: mpir.info,  Node: Random State Initialization,  Next: Random State Seeding,  Prev: Random Number Functions,  Up: Random Number Functions

9.1 Random State Initialization
===============================

 -- Function: void gmp_randinit_default (gmp_randstate_t STATE)
     Initialize STATE with a default algorithm.  This will be a
     compromise between speed and randomness, and is recommended for
     applications with no special requirements.  Currently this is
     'gmp_randinit_mt'.

 -- Function: void gmp_randinit_mt (gmp_randstate_t STATE)
     Initialize STATE for a Mersenne Twister algorithm.  This algorithm
     is fast and has good randomness properties.

 -- Function: void gmp_randinit_lc_2exp (gmp_randstate_t STATE, mpz_t A,
          mpir_ui C, mp_bitcnt_t M2EXP)
     Initialize STATE with a linear congruential algorithm X = (A*X + C)
     mod 2^M2EXP.

     The low bits of X in this algorithm are not very random.  The least
     significant bit will have a period no more than 2, and the second
     bit no more than 4, etc.  For this reason only the high half of
     each X is actually used.

     When a random number of more than M2EXP/2 bits is to be generated,
     multiple iterations of the recurrence are used and the results
     concatenated.

 -- Function: int gmp_randinit_lc_2exp_size (gmp_randstate_t STATE,
          mp_bitcnt_t SIZE)
     Initialize STATE for a linear congruential algorithm as per
     'gmp_randinit_lc_2exp'.  A, C and M2EXP are selected from a table,
     chosen so that SIZE bits (or more) of each X will be used, ie.
     M2EXP/2 >= SIZE.

     If successful the return value is non-zero.  If SIZE is bigger than
     the table data provides then the return value is zero.  The maximum
     SIZE currently supported is 128.

 -- Function: int gmp_randinit_set (gmp_randstate_t ROP, gmp_randstate_t
          OP)
     Initialize ROP with a copy of the algorithm and state from OP.

 -- Function: void gmp_randclear (gmp_randstate_t STATE)
     Free all memory occupied by STATE.


File: mpir.info,  Node: Random State Seeding,  Next: Random State Miscellaneous,  Prev: Random State Initialization,  Up: Random Number Functions

9.2 Random State Seeding
========================

 -- Function: void gmp_randseed (gmp_randstate_t STATE, mpz_t SEED)
 -- Function: void gmp_randseed_ui (gmp_randstate_t STATE, mpir_ui SEED)
     Set an initial seed value into STATE.

     The size of a seed determines how many different sequences of
     random numbers that it's possible to generate.  The "quality" of
     the seed is the randomness of a given seed compared to the previous
     seed used, and this affects the randomness of separate number
     sequences.  The method for choosing a seed is critical if the
     generated numbers are to be used for important applications, such
     as generating cryptographic keys.

     Traditionally the system time has been used to seed, but care needs
     to be taken with this.  If an application seeds often and the
     resolution of the system clock is low, then the same sequence of
     numbers might be repeated.  Also, the system time is quite easy to
     guess, so if unpredictability is required then it should definitely
     not be the only source for the seed value.  On some systems there's
     a special device '/dev/random' which provides random data better
     suited for use as a seed.


File: mpir.info,  Node: Random State Miscellaneous,  Prev: Random State Seeding,  Up: Random Number Functions

9.3 Random State Miscellaneous
==============================

 -- Function: mpir_ui gmp_urandomb_ui (gmp_randstate_t STATE, mpir_ui N)
     Return a uniformly distributed random number of N bits, ie. in the
     range 0 to 2^N-1 inclusive.  N must be less than or equal to the
     number of bits in an 'mpir_ui'.

 -- Function: mpir_ui gmp_urandomm_ui (gmp_randstate_t STATE, mpir_ui N)
     Return a uniformly distributed random number in the range 0 to N-1,
     inclusive.


File: mpir.info,  Node: Formatted Output,  Next: Formatted Input,  Prev: Random Number Functions,  Up: Top

10 Formatted Output
*******************

* Menu:

* Formatted Output Strings::
* Formatted Output Functions::
* C++ Formatted Output::


File: mpir.info,  Node: Formatted Output Strings,  Next: Formatted Output Functions,  Prev: Formatted Output,  Up: Formatted Output

10.1 Format Strings
===================

'gmp_printf' and friends accept format strings similar to the standard C
'printf' (*note Formatted Output: (libc)Formatted Output.).  A format
specification is of the form

     % [flags] [width] [.[precision]] [type] conv

   MPIR adds types 'Z', 'Q' and 'F' for 'mpz_t', 'mpq_t' and 'mpf_t'
respectively, 'M' for 'mp_limb_t', and 'N' for an 'mp_limb_t' array.
'Z', 'Q', 'M' and 'N' behave like integers.  'Q' will print a '/' and a
denominator, if needed.  'F' behaves like a float.  For example,

     mpz_t z;
     gmp_printf ("%s is an mpz %Zd\n", "here", z);

     mpq_t q;
     gmp_printf ("a hex rational: %#40Qx\n", q);

     mpf_t f;
     int   n;
     gmp_printf ("fixed point mpf %.*Ff with %d digits\n", n, f, n);

     mp_limb_t l;
     gmp_printf ("limb %Mu\n", limb);

     const mp_limb_t *ptr;
     mp_size_t       size;
     gmp_printf ("limb array %Nx\n", ptr, size);

   For 'N' the limbs are expected least significant first, as per the
'mpn' functions (*note Low-level Functions::).  A negative size can be
given to print the value as a negative.

   All the standard C 'printf' types behave the same as the C library
'printf', and can be freely intermixed with the MPIR extensions.  In the
current implementation the standard parts of the format string are
simply handed to 'printf' and only the MPIR extensions handled directly.

   The flags accepted are as follows.  GLIBC style ' is only for the
standard C types (not the MPIR types), and only if the C library
supports it.

     0         pad with zeros (rather than spaces)
     #         show the base with '0x', '0X' or '0'
     +         always show a sign
     (space)   show a space or a '-' sign
     '         group digits, GLIBC style (not MPIR
               types)

   The optional width and precision can be given as a number within the
format string, or as a '*' to take an extra parameter of type 'int', the
same as the standard 'printf'.

   The standard types accepted are as follows.  'h' and 'l' are
portable, the rest will depend on the compiler (or include files) for
the type and the C library for the output.

     h         short
     hh        char
     j         intmax_t or uintmax_t
     l         long or wchar_t
     ll        long long
     L         long double
     q         quad_t or u_quad_t
     t         ptrdiff_t
     z         size_t

The MPIR types are

     F         mpf_t, float conversions
     Q         mpq_t, integer conversions
     M         mp_limb_t, integer conversions
     N         mp_limb_t array, integer conversions
     Z         mpz_t, integer conversions

   The conversions accepted are as follows.  'a' and 'A' are always
supported for 'mpf_t' but depend on the C library for standard C float
types.  'm' and 'p' depend on the C library.

     a A       hex floats, C99 style
     c         character
     d         decimal integer
     e E       scientific format float
     f         fixed point float
     i         same as d
     g G       fixed or scientific float
     m         'strerror' string, GLIBC style
     n         store characters written so far
     o         octal integer
     p         pointer
     s         string
     u         unsigned integer
     x X       hex integer

   'o', 'x' and 'X' are unsigned for the standard C types, but for types
'Z', 'Q' and 'N' they are signed.  'u' is not meaningful for 'Z', 'Q'
and 'N'.

   'M' is a proxy for the C library 'l' or 'L', according to the size of
'mp_limb_t'.  Unsigned conversions will be usual, but a signed
conversion can be used and will interpret the value as a twos complement
negative.

   'n' can be used with any type, even the MPIR types.

   Other types or conversions that might be accepted by the C library
'printf' cannot be used through 'gmp_printf', this includes for instance
extensions registered with GLIBC 'register_printf_function'.  Also
currently there's no support for POSIX '$' style numbered arguments
(perhaps this will be added in the future).

   The precision field has it's usual meaning for integer 'Z' and float
'F' types, but is currently undefined for 'Q' and should not be used
with that.

   'mpf_t' conversions only ever generate as many digits as can be
accurately represented by the operand, the same as 'mpf_get_str' does.
Zeros will be used if necessary to pad to the requested precision.  This
happens even for an 'f' conversion of an 'mpf_t' which is an integer,
for instance 2^1024 in an 'mpf_t' of 128 bits precision will only
produce about 40 digits, then pad with zeros to the decimal point.  An
empty precision field like '%.Fe' or '%.Ff' can be used to specifically
request just the significant digits.

   The decimal point character (or string) is taken from the current
locale settings on systems which provide 'localeconv' (*note Locales and
Internationalization: (libc)Locales.).  The C library will normally do
the same for standard float output.

   The format string is only interpreted as plain 'char's, multibyte
characters are not recognised.  Perhaps this will change in the future.


File: mpir.info,  Node: Formatted Output Functions,  Next: C++ Formatted Output,  Prev: Formatted Output Strings,  Up: Formatted Output

10.2 Functions
==============

Each of the following functions is similar to the corresponding C
library function.  The basic 'printf' forms take a variable argument
list.  The 'vprintf' forms take an argument pointer, see *note Variadic
Functions: (libc)Variadic Functions, or 'man 3 va_start'.

   It should be emphasised that if a format string is invalid, or the
arguments don't match what the format specifies, then the behaviour of
any of these functions will be unpredictable.  GCC format string
checking is not available, since it doesn't recognise the MPIR
extensions.

   The file based functions 'gmp_printf' and 'gmp_fprintf' will return
-1 to indicate a write error.  Output is not "atomic", so partial output
may be produced if a write error occurs.  All the functions can return
-1 if the C library 'printf' variant in use returns -1, but this
shouldn't normally occur.

 -- Function: int gmp_printf (const char *FMT, ...)
 -- Function: int gmp_vprintf (const char *FMT, va_list AP)
     Print to the standard output 'stdout'.  Return the number of
     characters written, or -1 if an error occurred.

 -- Function: int gmp_fprintf (FILE *FP, const char *FMT, ...)
 -- Function: int gmp_vfprintf (FILE *FP, const char *FMT, va_list AP)
     Print to the stream FP.  Return the number of characters written,
     or -1 if an error occurred.

 -- Function: int gmp_sprintf (char *BUF, const char *FMT, ...)
 -- Function: int gmp_vsprintf (char *BUF, const char *FMT, va_list AP)
     Form a null-terminated string in BUF.  Return the number of
     characters written, excluding the terminating null.

     No overlap is permitted between the space at BUF and the string
     FMT.

     These functions are not recommended, since there's no protection
     against exceeding the space available at BUF.

 -- Function: int gmp_snprintf (char *BUF, size_t SIZE, const char *FMT,
          ...)
 -- Function: int gmp_vsnprintf (char *BUF, size_t SIZE, const char
          *FMT, va_list AP)
     Form a null-terminated string in BUF.  No more than SIZE bytes will
     be written.  To get the full output, SIZE must be enough for the
     string and null-terminator.

     The return value is the total number of characters which ought to
     have been produced, excluding the terminating null.  If RETVAL >=
     SIZE then the actual output has been truncated to the first SIZE-1
     characters, and a null appended.

     No overlap is permitted between the region {BUF,SIZE} and the FMT
     string.

     Notice the return value is in ISO C99 'snprintf' style.  This is so
     even if the C library 'vsnprintf' is the older GLIBC 2.0.x style.

 -- Function: int gmp_asprintf (char **PP, const char *FMT, ...)
 -- Function: int gmp_vasprintf (char **PP, const char *FMT, va_list AP)
     Form a null-terminated string in a block of memory obtained from
     the current memory allocation function (*note Custom Allocation::).
     The block will be the size of the string and null-terminator.  The
     address of the block in stored to *PP.  The return value is the
     number of characters produced, excluding the null-terminator.

     Unlike the C library 'asprintf', 'gmp_asprintf' doesn't return -1
     if there's no more memory available, it lets the current allocation
     function handle that.

 -- Function: int gmp_obstack_printf (struct obstack *OB, const char
          *FMT, ...)
 -- Function: int gmp_obstack_vprintf (struct obstack *OB, const char
          *FMT, va_list AP)
     Append to the current object in OB.  The return value is the number
     of characters written.  A null-terminator is not written.

     FMT cannot be within the current object in OB, since that object
     might move as it grows.

     These functions are available only when the C library provides the
     obstack feature, which probably means only on GNU systems, see
     *note Obstacks: (libc)Obstacks.


File: mpir.info,  Node: C++ Formatted Output,  Prev: Formatted Output Functions,  Up: Formatted Output

10.3 C++ Formatted Output
=========================

The following functions are provided in 'libmpirxx' (*note Headers and
Libraries::), which is built if C++ support is enabled (*note Build
Options::).  Prototypes are available from '<mpir.h>'.

 -- Function: ostream& operator<< (ostream& STREAM, mpz_t OP)
     Print OP to STREAM, using its 'ios' formatting settings.
     'ios::width' is reset to 0 after output, the same as the standard
     'ostream operator<<' routines do.

     In hex or octal, OP is printed as a signed number, the same as for
     decimal.  This is unlike the standard 'operator<<' routines on
     'int' etc, which instead give twos complement.

 -- Function: ostream& operator<< (ostream& STREAM, mpq_t OP)
     Print OP to STREAM, using its 'ios' formatting settings.
     'ios::width' is reset to 0 after output, the same as the standard
     'ostream operator<<' routines do.

     Output will be a fraction like '5/9', or if the denominator is 1
     then just a plain integer like '123'.

     In hex or octal, OP is printed as a signed value, the same as for
     decimal.  If 'ios::showbase' is set then a base indicator is shown
     on both the numerator and denominator (if the denominator is
     required).

 -- Function: ostream& operator<< (ostream& STREAM, mpf_t OP)
     Print OP to STREAM, using its 'ios' formatting settings.
     'ios::width' is reset to 0 after output, the same as the standard
     'ostream operator<<' routines do.

     The decimal point follows the standard library float 'operator<<',
     which on recent systems means the 'std::locale' imbued on STREAM.

     Hex and octal are supported, unlike the standard 'operator<<' on
     'double'.  The mantissa will be in hex or octal, the exponent will
     be in decimal.  For hex the exponent delimiter is an '@'.  This is
     as per 'mpf_out_str'.

     'ios::showbase' is supported, and will put a base on the mantissa,
     for example hex '0x1.8' or '0x0.8', or octal '01.4' or '00.4'.
     This last form is slightly strange, but at least differentiates
     itself from decimal.

   These operators mean that MPIR types can be printed in the usual C++
way, for example,

     mpz_t  z;
     int    n;
     ...
     cout << "iteration " << n << " value " << z << "\n";

   But note that 'ostream' output (and 'istream' input, *note C++
Formatted Input::) is the only overloading available for the MPIR types
and that for instance using '+' with an 'mpz_t' will have unpredictable
results.  For classes with overloading, see *note C++ Class Interface::.


File: mpir.info,  Node: Formatted Input,  Next: C++ Class Interface,  Prev: Formatted Output,  Up: Top

11 Formatted Input
******************

* Menu:

* Formatted Input Strings::
* Formatted Input Functions::
* C++ Formatted Input::


File: mpir.info,  Node: Formatted Input Strings,  Next: Formatted Input Functions,  Prev: Formatted Input,  Up: Formatted Input

11.1 Formatted Input Strings
============================

'gmp_scanf' and friends accept format strings similar to the standard C
'scanf' (*note Formatted Input: (libc)Formatted Input.).  A format
specification is of the form

     % [flags] [width] [type] conv

   MPIR adds types 'Z', 'Q' and 'F' for 'mpz_t', 'mpq_t' and 'mpf_t'
respectively.  'Z' and 'Q' behave like integers.  'Q' will read a '/'
and a denominator, if present.  'F' behaves like a float.

   MPIR variables don't require an '&' when passed to 'gmp_scanf', since
they're already "call-by-reference".  For example,

     /* to read say "a(5) = 1234" */
     int   n;
     mpz_t z;
     gmp_scanf ("a(%d) = %Zd\n", &n, z);

     mpq_t q1, q2;
     gmp_sscanf ("0377 + 0x10/0x11", "%Qi + %Qi", q1, q2);

     /* to read say "topleft (1.55,-2.66)" */
     mpf_t x, y;
     char  buf[32];
     gmp_scanf ("%31s (%Ff,%Ff)", buf, x, y);

   All the standard C 'scanf' types behave the same as in the C library
'scanf', and can be freely intermixed with the MPIR extensions.  In the
current implementation the standard parts of the format string are
simply handed to 'scanf' and only the MPIR extensions handled directly.

   The flags accepted are as follows.  'a' and ''' will depend on
support from the C library, and ''' cannot be used with MPIR types.

     *         read but don't store
     a         allocate a buffer (string conversions)
     '         grouped digits, GLIBC style (not MPIR
               types)

   The standard types accepted are as follows.  'h' and 'l' are
portable, the rest will depend on the compiler (or include files) for
the type and the C library for the input.

     h         short
     hh        char
     j         intmax_t or uintmax_t
     l         long int, double or wchar_t
     ll        long long
     L         long double
     q         quad_t or u_quad_t
     t         ptrdiff_t
     z         size_t

The MPIR types are

     F         mpf_t, float conversions
     Q         mpq_t, integer conversions
     Z         mpz_t, integer conversions

   The conversions accepted are as follows.  'p' and '[' will depend on
support from the C library, the rest are standard.

     c         character or characters
     d         decimal integer
     e E f g   float
     G
     i         integer with base indicator
     n         characters read so far
     o         octal integer
     p         pointer
     s         string of non-whitespace characters
     u         decimal integer
     x X       hex integer
     [         string of characters in a set

   'e', 'E', 'f', 'g' and 'G' are identical, they all read either fixed
point or scientific format, and either upper or lower case 'e' for the
exponent in scientific format.

   C99 style hex float format ('printf %a', *note Formatted Output
Strings::) is always accepted for 'mpf_t', but for the standard float
types it will depend on the C library.

   'x' and 'X' are identical, both accept both upper and lower case
hexadecimal.

   'o', 'u', 'x' and 'X' all read positive or negative values.  For the
standard C types these are described as "unsigned" conversions, but that
merely affects certain overflow handling, negatives are still allowed
(per 'strtoul', *note Parsing of Integers: (libc)Parsing of Integers.).
For MPIR types there are no overflows, so 'd' and 'u' are identical.

   'Q' type reads the numerator and (optional) denominator as given.  If
the value might not be in canonical form then 'mpq_canonicalize' must be
called before using it in any calculations (*note Rational Number
Functions::).

   'Qi' will read a base specification separately for the numerator and
denominator.  For example '0x10/11' would be 16/11, whereas '0x10/0x11'
would be 16/17.

   'n' can be used with any of the types above, even the MPIR types.
'*' to suppress assignment is allowed, though in that case it would do
nothing at all.

   Other conversions or types that might be accepted by the C library
'scanf' cannot be used through 'gmp_scanf'.

   Whitespace is read and discarded before a field, except for 'c' and
'[' conversions.

   For float conversions, the decimal point character (or string)
expected is taken from the current locale settings on systems which
provide 'localeconv' (*note Locales and Internationalization:
(libc)Locales.).  The C library will normally do the same for standard
float input.

   The format string is only interpreted as plain 'char's, multibyte
characters are not recognised.  Perhaps this will change in the future.


File: mpir.info,  Node: Formatted Input Functions,  Next: C++ Formatted Input,  Prev: Formatted Input Strings,  Up: Formatted Input

11.2 Formatted Input Functions
==============================

Each of the following functions is similar to the corresponding C
library function.  The plain 'scanf' forms take a variable argument
list.  The 'vscanf' forms take an argument pointer, see *note Variadic
Functions: (libc)Variadic Functions, or 'man 3 va_start'.

   It should be emphasised that if a format string is invalid, or the
arguments don't match what the format specifies, then the behaviour of
any of these functions will be unpredictable.  GCC format string
checking is not available, since it doesn't recognise the MPIR
extensions.

   No overlap is permitted between the FMT string and any of the results
produced.

 -- Function: int gmp_scanf (const char *FMT, ...)
 -- Function: int gmp_vscanf (const char *FMT, va_list AP)
     Read from the standard input 'stdin'.

 -- Function: int gmp_fscanf (FILE *FP, const char *FMT, ...)
 -- Function: int gmp_vfscanf (FILE *FP, const char *FMT, va_list AP)
     Read from the stream FP.

 -- Function: int gmp_sscanf (const char *S, const char *FMT, ...)
 -- Function: int gmp_vsscanf (const char *S, const char *FMT, va_list
          AP)
     Read from a null-terminated string S.

   The return value from each of these functions is the same as the
standard C99 'scanf', namely the number of fields successfully parsed
and stored.  '%n' fields and fields read but suppressed by '*' don't
count towards the return value.

   If end of input (or a file error) is reached before a character for a
field or a literal, and if no previous non-suppressed fields have
matched, then the return value is 'EOF' instead of 0.  A whitespace
character in the format string is only an optional match and doesn't
induce an 'EOF' in this fashion.  Leading whitespace read and discarded
for a field don't count as characters for that field.

   For the MPIR types, input parsing follows C99 rules, namely one
character of lookahead is used and characters are read while they
continue to meet the format requirements.  If this doesn't provide a
complete number then the function terminates, with that field not stored
nor counted towards the return value.  For instance with 'mpf_t' an
input '1.23e-XYZ' would be read up to the 'X' and that character pushed
back since it's not a digit.  The string '1.23e-' would then be
considered invalid since an 'e' must be followed by at least one digit.

   For the standard C types, in the current implementation MPIR calls
the C library 'scanf' functions, which might have looser rules about
what constitutes a valid input.

   Note that 'gmp_sscanf' is the same as 'gmp_fscanf' and only does one
character of lookahead when parsing.  Although clearly it could look at
its entire input, it is deliberately made identical to 'gmp_fscanf', the
same way C99 'sscanf' is the same as 'fscanf'.


File: mpir.info,  Node: C++ Formatted Input,  Prev: Formatted Input Functions,  Up: Formatted Input

11.3 C++ Formatted Input
========================

The following functions are provided in 'libmpirxx' (*note Headers and
Libraries::), which is built only if C++ support is enabled (*note Build
Options::).  Prototypes are available from '<mpir.h>'.

 -- Function: istream& operator>> (istream& STREAM, mpz_t ROP)
     Read ROP from STREAM, using its 'ios' formatting settings.

 -- Function: istream& operator>> (istream& STREAM, mpq_t ROP)
     An integer like '123' will be read, or a fraction like '5/9'.  No
     whitespace is allowed around the '/'.  If the fraction is not in
     canonical form then 'mpq_canonicalize' must be called (*note
     Rational Number Functions::) before operating on it.

     As per integer input, an '0' or '0x' base indicator is read when
     none of 'ios::dec', 'ios::oct' or 'ios::hex' are set.  This is done
     separately for numerator and denominator, so that for instance
     '0x10/11' is 16/11 and '0x10/0x11' is 16/17.

 -- Function: istream& operator>> (istream& STREAM, mpf_t ROP)
     Read ROP from STREAM, using its 'ios' formatting settings.

     Hex or octal floats are not supported, but might be in the future,
     or perhaps it's best to accept only what the standard float
     'operator>>' does.

   Note that digit grouping specified by the 'istream' locale is
currently not accepted.  Perhaps this will change in the future.


   These operators mean that MPIR types can be read in the usual C++
way, for example,

     mpz_t  z;
     ...
     cin >> z;

   But note that 'istream' input (and 'ostream' output, *note C++
Formatted Output::) is the only overloading available for the MPIR types
and that for instance using '+' with an 'mpz_t' will have unpredictable
results.  For classes with overloading, see *note C++ Class Interface::.


File: mpir.info,  Node: C++ Class Interface,  Next: .Net Interface,  Prev: Formatted Input,  Up: Top

12 C++ Class Interface
**********************

This chapter describes the C++ class based interface to MPIR.

   All MPIR C language types and functions can be used in C++ programs,
since 'mpir.h' has 'extern "C"' qualifiers, but the class interface
offers overloaded functions and operators which may be more convenient.

   Due to the implementation of this interface, a reasonably recent C++
compiler is required, one supporting namespaces, partial specialization
of templates and member templates.  For GCC this means version 2.91 or
later.

   *Everything described in this chapter is to be considered preliminary
and might be subject to incompatible changes if some unforeseen
difficulty reveals itself.*

* Menu:

* C++ Interface General::
* C++ Interface Integers::
* C++ Interface Rationals::
* C++ Interface Floats::
* C++ Interface Random Numbers::
* C++ Interface Limitations::


File: mpir.info,  Node: C++ Interface General,  Next: C++ Interface Integers,  Prev: C++ Class Interface,  Up: C++ Class Interface

12.1 C++ Interface General
==========================

All the C++ classes and functions are available with

     #include <mpirxx.h>

   Programs should be linked with the 'libmpirxx' and 'libmpir'
libraries.  For example,

     g++ mycxxprog.cc -lmpirxx -lmpir

The classes defined are

 -- Class: mpz_class
 -- Class: mpq_class
 -- Class: mpf_class

   The standard operators and various standard functions are overloaded
to allow arithmetic with these classes.  For example,

     int
     main (void)
     {
       mpz_class a, b, c;

       a = 1234;
       b = "-5678";
       c = a+b;
       cout << "sum is " << c << "\n";
       cout << "absolute value is " << abs(c) << "\n";

       return 0;
     }

   An important feature of the implementation is that an expression like
'a=b+c' results in a single call to the corresponding 'mpz_add', without
using a temporary for the 'b+c' part.  Expressions which by their nature
imply intermediate values, like 'a=b*c+d*e', still use temporaries
though.

   The classes can be freely intermixed in expressions, as can the
classes and the standard types 'mpir_si', 'mpir_ui' and 'double'.
Smaller types like 'int' or 'float' can also be intermixed, since C++
will promote them.

   Note that 'bool' is not accepted directly, but must be explicitly
cast to an 'int' first.  This is because C++ will automatically convert
any pointer to a 'bool', so if MPIR accepted 'bool' it would make all
sorts of invalid class and pointer combinations compile but almost
certainly not do anything sensible.

   Conversions back from the classes to standard C++ types aren't done
automatically, instead member functions like 'get_si' are provided (see
the following sections for details).

   Also there are no automatic conversions from the classes to the
corresponding MPIR C types, instead a reference to the underlying C
object can be obtained with the following functions,

 -- Function: mpz_t mpz_class::get_mpz_t ()
 -- Function: mpq_t mpq_class::get_mpq_t ()
 -- Function: mpf_t mpf_class::get_mpf_t ()

   These can be used to call a C function which doesn't have a C++ class
interface.  For example to set 'a' to the GCD of 'b' and 'c',

     mpz_class a, b, c;
     ...
     mpz_gcd (a.get_mpz_t(), b.get_mpz_t(), c.get_mpz_t());

   In the other direction, a class can be initialized from the
corresponding MPIR C type, or assigned to if an explicit constructor is
used.  In both cases this makes a copy of the value, it doesn't create
any sort of association.  For example,

     mpz_t z;
     // ... init and calculate z ...
     mpz_class x(z);
     mpz_class y;
     y = mpz_class (z);

   There are no namespace setups in 'mpirxx.h', all types and functions
are simply put into the global namespace.  This is what 'mpir.h' has
done in the past, and continues to do for compatibility.  The extras
provided by 'mpirxx.h' follow MPIR naming conventions and are unlikely
to clash with anything.


File: mpir.info,  Node: C++ Interface Integers,  Next: C++ Interface Rationals,  Prev: C++ Interface General,  Up: C++ Class Interface

12.2 C++ Interface Integers
===========================

 -- Function: void mpz_class::mpz_class (type N)
     Construct an 'mpz_class'.  All the standard C++ types may be used
     'long double', and all the MPIR C++ classes can be used.  Any
     necessary conversion follows the corresponding C function, for
     example 'double' follows 'mpz_set_d' (*note Assigning Integers::).

 -- Function: void mpz_class::mpz_class (mpz_t Z)
     Construct an 'mpz_class' from an 'mpz_t'.  The value in Z is copied
     into the new 'mpz_class', there won't be any permanent association
     between it and Z.

 -- Function: void mpz_class::mpz_class (const char *S)
 -- Function: void mpz_class::mpz_class (const char *S, int BASE = 0)
 -- Function: void mpz_class::mpz_class (const string& S)
 -- Function: void mpz_class::mpz_class (const string& S, int BASE = 0)
     Construct an 'mpz_class' converted from a string using
     'mpz_set_str' (*note Assigning Integers::).

     If the string is not a valid integer, an 'std::invalid_argument'
     exception is thrown.  The same applies to 'operator='.

 -- Function: mpz_class operator"" _mpz (const char *STR)
     With C++11 compilers, integers can be constructed with the syntax
     '123_mpz' which is equivalent to 'mpz_class("123")'.

 -- Function: mpz_class operator/ (mpz_class A, mpz_class D)
 -- Function: mpz_class operator% (mpz_class A, mpz_class D)
     Divisions involving 'mpz_class' round towards zero, as per the
     'mpz_tdiv_q' and 'mpz_tdiv_r' functions (*note Integer Division::).
     This is the same as the C99 '/' and '%' operators.

     The 'mpz_fdiv...' or 'mpz_cdiv...' functions can always be called
     directly if desired.  For example,

          mpz_class q, a, d;
          ...
          mpz_fdiv_q (q.get_mpz_t(), a.get_mpz_t(), d.get_mpz_t());

 -- Function: mpz_class abs (mpz_class OP1)
 -- Function: int cmp (mpz_class OP1, type OP2)
 -- Function: int cmp (type OP1, mpz_class OP2)

 -- Function: bool mpz_class::fits_sint_p (void)
 -- Function: bool mpz_class::fits_slong_p (void)
 -- Function: bool mpz_class::fits_sshort_p (void)

 -- Function: bool mpz_class::fits_uint_p (void)
 -- Function: bool mpz_class::fits_ulong_p (void)
 -- Function: bool mpz_class::fits_ushort_p (void)

 -- Function: double mpz_class::get_d (void)
 -- Function: mpir_si mpz_class::get_si (void)
 -- Function: string mpz_class::get_str (int BASE = 10)
 -- Function: mpir_ui mpz_class::get_ui (void)

 -- Function: int mpz_class::set_str (const char *STR, int BASE)
 -- Function: int mpz_class::set_str (const string& STR, int BASE)
 -- Function: int sgn (mpz_class OP)
 -- Function: mpz_class sqrt (mpz_class OP)
 -- Function: void mpz_class::swap (mpz_class& OP)
 -- Function: void swap (mpz_class& OP1, mpz_class& OP2)
     These functions provide a C++ class interface to the corresponding
     MPIR C routines.

     'cmp' can be used with any of the classes or the standard C++
     types, except 'long double'.


   Overloaded operators for combinations of 'mpz_class' and 'double' are
provided for completeness, but it should be noted that if the given
'double' is not an integer then the way any rounding is done is
currently unspecified.  The rounding might take place at the start, in
the middle, or at the end of the operation, and it might change in the
future.

   Conversions between 'mpz_class' and 'double', however, are defined to
follow the corresponding C functions 'mpz_get_d' and 'mpz_set_d'.  And
comparisons are always made exactly, as per 'mpz_cmp_d'.


File: mpir.info,  Node: C++ Interface Rationals,  Next: C++ Interface Floats,  Prev: C++ Interface Integers,  Up: C++ Class Interface

12.3 C++ Interface Rationals
============================

In all the following constructors, if a fraction is given then it should
be in canonical form, or if not then 'mpq_class::canonicalize' called.

 -- Function: void mpq_class::mpq_class (type OP)
 -- Function: void mpq_class::mpq_class (integer NUM, integer DEN)
     Construct an 'mpq_class'.  The initial value can be a single value
     of any type, or a pair of integers ('mpz_class' or standard C++
     integer types) representing a fraction, except that 'long double'
     is not supported.  For example,

          mpq_class q (99);
          mpq_class q (1.75);
          mpq_class q (1, 3);

 -- Function: void mpq_class::mpq_class (mpq_t Q)
     Construct an 'mpq_class' from an 'mpq_t'.  The value in Q is copied
     into the new 'mpq_class', there won't be any permanent association
     between it and Q.

 -- Function: void mpq_class::mpq_class (const char *S)
 -- Function: void mpq_class::mpq_class (const char *S, int BASE = 0)
 -- Function: void mpq_class::mpq_class (const string& S)
 -- Function: void mpq_class::mpq_class (const string& S, int BASE = 0)
     Construct an 'mpq_class' converted from a string using
     'mpq_set_str' (*note Initializing Rationals::).

     If the string is not a valid rational, an 'std::invalid_argument'
     exception is thrown.  The same applies to 'operator='.

 -- Function: mpq_class operator"" _mpq (const char *STR)
     With C++11 compilers, integral rationals can be constructed with
     the syntax '123_mpq' which is equivalent to 'mpq_class(123_mpz)'.
     Other rationals can be built as '-1_mpq/2' or '0xb_mpq/123456_mpz'.

 -- Function: void mpq_class::canonicalize ()
     Put an 'mpq_class' into canonical form, as per *note Rational
     Number Functions::.  All arithmetic operators require their
     operands in canonical form, and will return results in canonical
     form.

 -- Function: mpq_class abs (mpq_class OP)
 -- Function: int cmp (mpq_class OP1, type OP2)
 -- Function: int cmp (type OP1, mpq_class OP2)

 -- Function: double mpq_class::get_d (void)
 -- Function: string mpq_class::get_str (int BASE = 10)

 -- Function: int mpq_class::set_str (const char *STR, int BASE)
 -- Function: int mpq_class::set_str (const string& STR, int BASE)
 -- Function: int sgn (mpq_class OP)
 -- Function: void mpq_class::swap (mpq_class& OP)
 -- Function: void swap (mpq_class& OP1, mpq_class& OP2)
     These functions provide a C++ class interface to the corresponding
     MPIR C routines.

     'cmp' can be used with any of the classes or the standard C++
     types, except 'long double'.

 -- Function: mpz_class& mpq_class::get_num ()
 -- Function: mpz_class& mpq_class::get_den ()
     Get a reference to an 'mpz_class' which is the numerator or
     denominator of an 'mpq_class'.  This can be used both for read and
     write access.  If the object returned is modified, it modifies the
     original 'mpq_class'.

     If direct manipulation might produce a non-canonical value, then
     'mpq_class::canonicalize' must be called before further operations.

 -- Function: mpz_t mpq_class::get_num_mpz_t ()
 -- Function: mpz_t mpq_class::get_den_mpz_t ()
     Get a reference to the underlying 'mpz_t' numerator or denominator
     of an 'mpq_class'.  This can be passed to C functions expecting an
     'mpz_t'.  Any modifications made to the 'mpz_t' will modify the
     original 'mpq_class'.

     If direct manipulation might produce a non-canonical value, then
     'mpq_class::canonicalize' must be called before further operations.

 -- Function: istream& operator>> (istream& STREAM, mpq_class& ROP);
     Read ROP from STREAM, using its 'ios' formatting settings, the same
     as 'mpq_t operator>>' (*note C++ Formatted Input::).

     If the ROP read might not be in canonical form then
     'mpq_class::canonicalize' must be called.


File: mpir.info,  Node: C++ Interface Floats,  Next: C++ Interface Random Numbers,  Prev: C++ Interface Rationals,  Up: C++ Class Interface

12.4 C++ Interface Floats
=========================

When an expression requires the use of temporary intermediate
'mpf_class' values, like 'f=g*h+x*y', those temporaries will have the
same precision as the destination 'f'.  Explicit constructors can be
used if this doesn't suit.

 -- Function: mpf_class::mpf_class (type OP)
 -- Function: mpf_class::mpf_class (type OP, mpir_ui PREC)
     Construct an 'mpf_class'.  Any standard C++ type can be used,
     except 'long double', and any of the MPIR C++ classes can be used.

     If PREC is given, the initial precision is that value, in bits.  If
     PREC is not given, then the initial precision is determined by the
     type of OP given.  An 'mpz_class', 'mpq_class', or C++ builtin type
     will give the default 'mpf' precision (*note Initializing
     Floats::).  An 'mpf_class' or expression will give the precision of
     that value.  The precision of a binary expression is the higher of
     the two operands.

          mpf_class f(1.5);        // default precision
          mpf_class f(1.5, 500);   // 500 bits (at least)
          mpf_class f(x);          // precision of x
          mpf_class f(abs(x));     // precision of x
          mpf_class f(-g, 1000);   // 1000 bits (at least)
          mpf_class f(x+y);        // greater of precisions of x and y

 -- Function: void mpf_class::mpf_class (const char *S)
 -- Function: void mpf_class::mpf_class (const char *S, mpir_ui PREC,
          int BASE = 0)
 -- Function: void mpf_class::mpf_class (const string& S)
 -- Function: void mpf_class::mpf_class (const string& S, mpir_ui PREC,
          int BASE = 0)
     Construct an 'mpf_class' converted from a string using
     'mpf_set_str' (*note Assigning Floats::).  If PREC is given, the
     initial precision is that value, in bits.  If not, the default
     'mpf' precision (*note Initializing Floats::) is used.

     If the string is not a valid float, an 'std::invalid_argument'
     exception is thrown.  The same applies to 'operator='.

 -- Function: mpf_class operator"" _mpf (const char *STR)
     With C++11 compilers, floats can be constructed with the syntax
     '1.23e-1_mpf' which is equivalent to 'mpf_class("1.23e-1")'.

 -- Function: mpf_class& mpf_class::operator= (type OP)
     Convert and store the given OP value to an 'mpf_class' object.  The
     same types are accepted as for the constructors above.

     Note that 'operator=' only stores a new value, it doesn't copy or
     change the precision of the destination, instead the value is
     truncated if necessary.  This is the same as 'mpf_set' etc.  Note
     in particular this means for 'mpf_class' a copy constructor is not
     the same as a default constructor plus assignment.

          mpf_class x (y);   // x created with precision of y

          mpf_class x;       // x created with default precision
          x = y;             // value truncated to that precision

     Applications using templated code may need to be careful about the
     assumptions the code makes in this area, when working with
     'mpf_class' values of various different or non-default precisions.
     For instance implementations of the standard 'complex' template
     have been seen in both styles above, though of course 'complex' is
     normally only actually specified for use with the builtin float
     types.

 -- Function: mpf_class abs (mpf_class OP)
 -- Function: mpf_class ceil (mpf_class OP)
 -- Function: int cmp (mpf_class OP1, type OP2)
 -- Function: int cmp (type OP1, mpf_class OP2)

 -- Function: bool mpf_class::fits_sint_p (void)
 -- Function: bool mpf_class::fits_slong_p (void)
 -- Function: bool mpf_class::fits_sshort_p (void)

 -- Function: bool mpf_class::fits_uint_p (void)
 -- Function: bool mpf_class::fits_ulong_p (void)
 -- Function: bool mpf_class::fits_ushort_p (void)

 -- Function: mpf_class floor (mpf_class OP)
 -- Function: mpf_class hypot (mpf_class OP1, mpf_class OP2)

 -- Function: double mpf_class::get_d (void)
 -- Function: mpir_si mpf_class::get_si (void)
 -- Function: string mpf_class::get_str (mp_exp_t& EXP, int BASE = 10,
          size_t DIGITS = 0)
 -- Function: mpir_ui mpf_class::get_ui (void)

 -- Function: int mpf_class::set_str (const char *STR, int BASE)
 -- Function: int mpf_class::set_str (const string& STR, int BASE)
 -- Function: int sgn (mpf_class OP)
 -- Function: mpf_class sqrt (mpf_class OP)
 -- Function: void mpf_class::swap (mpf_class& OP)
 -- Function: void swap (mpf_class& OP1, mpf_class& OP2)
 -- Function: mpf_class trunc (mpf_class OP)
     These functions provide a C++ class interface to the corresponding
     MPIR C routines.

     'cmp' can be used with any of the classes or the standard C++
     types, except 'long double'.

     The accuracy provided by 'hypot' is not currently guaranteed.

 -- Function: mp_bitcnt_t mpf_class::get_prec ()
 -- Function: void mpf_class::set_prec (mp_bitcnt_t PREC)
 -- Function: void mpf_class::set_prec_raw (mp_bitcnt_t PREC)
     Get or set the current precision of an 'mpf_class'.

     The restrictions described for 'mpf_set_prec_raw' (*note
     Initializing Floats::) apply to 'mpf_class::set_prec_raw'.  Note in
     particular that the 'mpf_class' must be restored to it's allocated
     precision before being destroyed.  This must be done by application
     code, there's no automatic mechanism for it.


File: mpir.info,  Node: C++ Interface Random Numbers,  Next: C++ Interface Limitations,  Prev: C++ Interface Floats,  Up: C++ Class Interface

12.5 C++ Interface Random Numbers
=================================

 -- Class: gmp_randclass
     The C++ class interface to the MPIR random number functions uses
     'gmp_randclass' to hold an algorithm selection and current state,
     as per 'gmp_randstate_t'.

 -- Function: gmp_randclass::gmp_randclass (void (*RANDINIT)
          (gmp_randstate_t, ...), ...)
     Construct a 'gmp_randclass', using a call to the given RANDINIT
     function (*note Random State Initialization::).  The arguments
     expected are the same as RANDINIT, but with 'mpz_class' instead of
     'mpz_t'.  For example,

          gmp_randclass r1 (gmp_randinit_default);
          gmp_randclass r2 (gmp_randinit_lc_2exp_size, 32);
          gmp_randclass r3 (gmp_randinit_lc_2exp, a, c, m2exp);
          gmp_randclass r4 (gmp_randinit_mt);

     'gmp_randinit_lc_2exp_size' will fail if the size requested is too
     big, an 'std::length_error' exception is thrown in that case.

 -- Function: void gmp_randclass::seed (mpir_ui S)
 -- Function: void gmp_randclass::seed (mpz_class S)
     Seed a random number generator.  See *note Random Number
     Functions::, for how to choose a good seed.

 -- Function: mpz_class gmp_randclass::get_z_bits (mpir_ui BITS)
 -- Function: mpz_class gmp_randclass::get_z_bits (mpz_class BITS)
     Generate a random integer with a specified number of bits.

 -- Function: mpz_class gmp_randclass::get_z_range (mpz_class N)
     Generate a random integer in the range 0 to N-1 inclusive.

 -- Function: mpf_class gmp_randclass::get_f ()
 -- Function: mpf_class gmp_randclass::get_f (mpir_ui PREC)
     Generate a random float F in the range 0 <= F < 1.  F will be to
     PREC bits precision, or if PREC is not given then to the precision
     of the destination.  For example,

          gmp_randclass  r;
          ...
          mpf_class  f (0, 512);   // 512 bits precision
          f = r.get_f();           // random number, 512 bits


File: mpir.info,  Node: C++ Interface Limitations,  Prev: C++ Interface Random Numbers,  Up: C++ Class Interface

12.6 C++ Interface Limitations
==============================

'mpq_class' and Templated Reading
     A generic piece of template code probably won't know that
     'mpq_class' requires a 'canonicalize' call if inputs read with
     'operator>>' might be non-canonical.  This can lead to incorrect
     results.

     'operator>>' behaves as it does for reasons of efficiency.  A
     canonicalize can be quite time consuming on large operands, and is
     best avoided if it's not necessary.

     But this potential difficulty reduces the usefulness of
     'mpq_class'.  Perhaps a mechanism to tell 'operator>>' what to do
     will be adopted in the future, maybe a preprocessor define, a
     global flag, or an 'ios' flag pressed into service.  Or maybe, at
     the risk of inconsistency, the 'mpq_class' 'operator>>' could
     canonicalize and leave 'mpq_t' 'operator>>' not doing so, for use
     on those occasions when that's acceptable.  Send feedback or
     alternate ideas to <http://groups.google.com/group/mpir-devel>.

Subclassing
     Subclassing the MPIR C++ classes works, but is not currently
     recommended.

     Expressions involving subclasses resolve correctly (or seem to),
     but in normal C++ fashion the subclass doesn't inherit constructors
     and assignments.  There's many of those in the MPIR classes, and a
     good way to reestablish them in a subclass is not yet provided.

Templated Expressions
     A subtle difficulty exists when using expressions together with
     application-defined template functions.  Consider the following,
     with 'T' intended to be some numeric type,

          template <class T>
          T fun (const T &, const T &);

     When used with, say, plain 'mpz_class' variables, it works fine:
     'T' is resolved as 'mpz_class'.

          mpz_class f(1), g(2);
          fun (f, g);    // Good

     But when one of the arguments is an expression, it doesn't work.

          mpz_class f(1), g(2), h(3);
          fun (f, g+h);  // Bad

     This is because 'g+h' ends up being a certain expression template
     type internal to 'mpirxx.h', which the C++ template resolution
     rules are unable to automatically convert to 'mpz_class'.  The
     workaround is simply to add an explicit cast.

          mpz_class f(1), g(2), h(3);
          fun (f, mpz_class(g+h));  // Good

     Similarly, within 'fun' it may be necessary to cast an expression
     to type 'T' when calling a templated 'fun2'.

          template <class T>
          void fun (T f, T g)
          {
            fun2 (f, f+g);     // Bad
          }

          template <class T>
          void fun (T f, T g)
          {
            fun2 (f, T(f+g));  // Good
          }


File: mpir.info,  Node: .Net Interface,  Next: Custom Allocation,  Prev: C++ Class Interface,  Up: Top

13 .Net Interface
*****************

This chapter describes the Microsoft.Net wrapper around MPIR.

   If you are a .Net developer on MS Windows, using MPIR is possible via
the basic managed-to-native interop tooling provided by .Net.  While
this would allow access to the full MPIR intreface, you would
essentially be embedding C code inside whatever .Net language you are
using.  This would virtually require familiarity with C/C++, the interop
artefacts in your code would be distractingly evident, and it would be
hard to maintain a smooth code style around managed/native transitions.

   MPIR offers an alternative that addresses these issues: *MPIR.Net*.
MPIR.Net is a Microsoft Visual Studio solution that interoperates with
MPIR and exposes a full managed interface built from scratch, for
consumption in any .Net language.  It internalizes all C-rooted
idiosynchrasies and allows you to work with MPIR objects through managed
classes that perform all necessary marshaling behind the scenes.  It
strives to provide maximum performance by implementing MPIR operations
with direct calls to the native routines while not requiring you to
sacrifice any of your code style.  It eliminates any requirement of
fluency in C, yet delivers the performance of native MPIR. In fact, it
can consume any native MPIR build, including all supported
processor-specific builds, and can thus take advantage of the entire
wealth of assembly-optimized MPIR routines.

   MPIR.Net is, however, limited to MS Windows and Visual Studio at this
time.  The managed interface is written in Microsoft C++/CLI, which ties
you to that specific environment.  If you use .Net on Linux and use a
compiler other than Visual Studio, MPIR.Net will not work for you, but
then again, you may already have better native interop facilities
available to you than your Windows colleagues, making MPIR.Net rather
moot.

   MPIR.Net is bundled with MPIR as an optional feature.  To build it,
you still need to build the native MPIR library first.  As you do, you
can select the best processor architecture that matches your
requirements.  Then you build MPIR.Net, and it is linked statically to
the native MPIR library, producing a managed assembly.  Thus, to build
MPIR.Net, you need to be familiar with the MPIR build process on
Windows, and have a recent version of Visual Studio available (a
community edition will suffice).

* Menu:

* MPIR.Net Feature Overview::
* Building MPIR.Net::
* MPIR.Net Integers::
* MPIR.Net Rationals::
* MPIR.Net Floats::
* MPIR.Net Random Numbers::
* MPIR.Net Settings::


File: mpir.info,  Node: MPIR.Net Feature Overview,  Next: Building MPIR.Net,  Prev: .Net Interface,  Up: .Net Interface

13.1 MPIR.Net Feature Overview
==============================

MPIR.Net exposes the following main classes:

 -- Class: HugeInt
 -- Class: HugeRational
 -- Class: HugeFloat
 -- Class: MpirRandom

   The standard operators are overloaded to allow arithmetic with these
classes.  For example,

     void Calculate()
     {
       using (var a = new HugeInt(1234))
       using (var b = new HugeInt("-5678"))
       using (var c = new HugeInt(a + b))
       {
         Debug.WriteLine("Result: {0}", c);
       }
     }

   MPIR.Net's multi-precision classes implement 'IDisposable', and the
recommended usage for local instances is as shown above, within a
'using' clause to guarantee native memory clean-up when a variable is
disposed.

   References that go out of scope without having been disposed are
subject to the normal .Net garbage collection, which in most cases
invokes object finalizers, and those in turn deallocate native memory.
Applications that don't have memory pressure should work just fine
either way, although deterministic disposal is a best practice.

   Like MPIR's native *note C++ Class Interface::, MPIR.Net implements
an expression like 'a.Value = b + c' with a single call to the
corresponding native 'mpz_add', without using a temporary for the 'b +
c' part.  More complex expressions that do not have a single-call native
implementation like 'a.Value = b*c + d*e', still use temporary
variables.  Importantly, 'a.Value = a + b*c' and the like will utilize
the native 'mpz_addmul', etc.  Note that in all of the above cases the
assignment syntax is to set the 'Value' property; more on that below.

   Another similarity of MPIR.Net with the C++ interface is the deferral
of evaluation.  All arithmetic operations and many methods produce an
expression object rather than an immediate result.  This allows
expressions of arbitrary complexity to be built.  They are not evaluated
until the expression is assigned to a destination variable, or when
calling a method that produces a primitive (non-MPIR.Net type) result.
For example:

     void Calculate()
     {
       var a = new HugeInt(12345);
       var b = new HugeInt(67890);
       var sum = a + b;                // produces an expression
       var doubleSum = sum * 2;        // produces a new expression
       bool positive = doubleSum > 0;  // evaluates the doubleSum expression
       int sumSign = doubleSum.Sign(); // evaluates the doubleSum expression
       a.Value = doubleSum - 4;        // evaluates the doubleSum expression
     }

   Here the addition and multiplication in '(a + b) * 2' are computed
three times because they are part of an expression that is consumed by
three destinations, 'positive', 'sumSign', and 'a'.  To avoid the triple
addition, this method should be re-written as:

     void Calculate()
     {
       var a = new HugeInt(12345);
       var b = new HugeInt(67890);
       var sum = a + b;                      // produces an expression
       var doubleSum = new HugeInt(sum * 2); // evaluates the expression
       bool positive = doubleSum > 0;        // evaluates the > comparison
       int sumSign = doubleSum.Sign();       // computes the sign
       a.Value = doubleSum - 4;              // computes the subtraction
     }

   Now the result of '(a + b) * 2' is computed once and stored in an
intermediate variable, whose value is used in subsequent statements.
This code can be shortened as follows without changing the internal
calculation:

     void Calculate()
     {
       var a = new HugeInt(12345);
       var b = new HugeInt(67890);
       var doubleSum = new HugeInt((a + b) * 2); // evaluates the expression
       var positive = doubleSum > 0;             // evaluates the > comparison
       var sumSign = doubleSum.Sign();           // computes the sign
       a.Value = doubleSum - 4;                  // computes the subtraction
     }

   The main idiosyncrasy of MPIR.Net is its assignment pattern.
MPIR.Net types are implemented as reference types with value semantics.
Like .Net Strings, the objects themselves are just lightweight pointers
to data allocated elsewhere.  In this case, the data is in native
memory.  Unlike Strings, MPIR types are mutable.

   Value semantics requires you to be able to code statements like 'a =
b + c'.  However, .Net (outside of C++) does not allow overloading the
assignment operator, while assigning references would necessitate some
unnecessary duplication and extra memory allocations, require reliance
on the garbage collector, and prevent the use of 'mpz_addmul' and the
like.

   To solve this problem, MPIR.Net uses the property assignment.  All
MPIR.Net types have a 'Value' property.  The magic of this property is
in its setter, which does what an overloaded assignment operator would
do in C++.  So you write 'a.Value = b + c' to calculate the sum of 'b'
and 'c' and store the result in the existing variable 'a'.  This seems
to be as close to an overloaded assignment as you can get in .Net, but
is fluent enough to become a quick habit, and additionally reinforces
the concept that an existing object can change its value while reusing
internally allocated memory.

   Setting 'Value' evaluates the expression being assigned.  Since at
this point the destination is known, 'mpz_addmul' and similar can be
recognized and invoked.

   Reading this property is less interesting, as it's equivalent to but
wordier than using the reference itself, i.e.  'a + b' is equivalent to
'a.Value + b.Value'.  However it is still useful for making possible
constructs such as 'a.Value += 5', 'a.Value *= 10', etc.

   If you absent-mindedly type 'a = b + c' or 'a *= 10', these will not
compile because there is no implicit conversion from an expression.  If
an implicit conversion were defined, such code would incur an extra
allocation plus garbage collection, making it potentially slower than
performing the same operations on 'a.Value'.  It would also not compile
if the destination were a local variable defined in a 'using' clause, as
is the recommended practice for method-local instances.

   Care should be taken with the construct 'var a = b;'.  While
perfectly legal (and cannot be made otherwise) in .Net, this only
creates a copy of the managed reference to the same MPIR.Net object,
without any copying of the data.  If 'b' is subsequently disposed,
referencing 'a' will throw an error.

   MPIR classes can be intermixed in expressions to some degree.  For
example, most arithmetic operations with rational operands will accept
integers.  Where mixed operations are defined in MPIR, they are also
implemented in MPIR.Net.  Floats, on the other hand, typically don't
accept operands of other types.  There is some cost associated with
creating a floating point instance out of an integer, which would not be
evident if automatic promotion existed.  Use explicit constructors to
convert instances of one type to new instances of other types, or one of
the 'SetTo()' overloads to save the result into an existing instance.

   MPIR classes can also be intermixed in expressions with primitive
types.  For 64-bit builds, this includes 'long' and 'ulong', which
correspond to an MPIR limb.  For 32-bit builds, 'int' and 'uint' are the
largest primitive types you can use.  Smaller integer primitives can
always be used because they will be promoted by .Net.

   Conversions back from MPIR classes to primitive types aren't done
automatically, instead methods 'ToLong()'/'ToUlong()' for 64-bit builds
or 'ToInt()'/'ToUint()' are provided.  Integers also implement
'GetLimb()'.


File: mpir.info,  Node: Building MPIR.Net,  Next: MPIR.Net Integers,  Prev: MPIR.Net Feature Overview,  Up: .Net Interface

13.2 Building MPIR.Net
======================

To build MPIR.Net, follow the steps below:

  1. Get the sources

  2. Build MPIR

  3. Run MPIR unit tests

  4. Build MPIR.Net

  5. Run MPIR.Net unit tests

  6. Reference MPIR.Net in your managed project

   *Get the sources*: Clone the MPIR repository on GitHub to get the
latest stable MPIR release.  This repository includes MPIR.Net.  Or you
can clone the MPIR.Net fork, which will get you the development
repository.

   *Build MPIR*: Once you have the sources, you will need to build MPIR
first.  Read the MPIR manual, available as a Documentation link on the
MPIR page, for full details.  Since MPIR.Net currently requires Windows,
you will need to build MPIR for Windows using Microsoft Visual Studio.
MPIR provides solutions for the three latest versions of Visual Studio,
and includes full build instructions.  You can select either a generic C
build or an optimized build for a specific processor.  You must also
select the Windows architecture desired (32-bit or 64-bit), and build
configuration (debug/release).  You will need to build MPIR as Lib, not
DLL, to use it with MPIR.Net.

   *Run MPIR unit tests*: MPIR contains a full suite of unit tests that
you can (and should) execute to validate your build.  It is a large and
complex project, and many things can go wrong while building from
sources.  Building and running the tests only takes a few of minutes and
might save you a lot of headache.  Note that you must also build MPIR's
C++ interface to run unit tests, however it is not a dependency for
MPIR.Net.

   *Build MPIR.Net*: Next, load the MPIR.Net solution in Visual Studio.
It is located in the MPIR.Net folder, under which there are folders for
the different supported Visual Studio versions.  The projects are set up
to look for the previously built MPIR library in its normal location in
the Lib folder.  You will need to select the same architecture (x64 or
x86) and configuration (debug/release) as when you built MPIR. Then
simply build the solution, and you are good to go.

   *Run MPIR.Net unit tests*: MPIR.Net includes its own suite of unit
tests.  Because MPIR.Net is a wrapper around MPIR, these tests simply
ensure that the right routines in MPIR are being called, but do not
validate the robustness of the MPIR build itself.  Thus, it is necessary
to run both MPIR tests and MPIR.Net tests.  MPIR.Net tests, though, are
easier to run because they are included right in the MPIR.Net solution.

   Through binary compatibility with GMP 5.x, MPIR 2.x inherits a known
issue that causes a few MPIR.Net tests (2 for x86, 3 for x64) to fail.
The issue has been corrected in GMP 6.x, and is expected to be corrected
correspondingly in MPIR 3.x.  Because this behavior is not intuitive,
these tests remain in their current failing state until this is
resolved.

   *Reference MPIR.Net*: With the MPIR.Net assembly built, you're ready
to create your own project in a .Net language of your choice, add a
reference to MPIR.Net, and take advantage of the great mathematical
powers of MPIR!


File: mpir.info,  Node: MPIR.Net Integers,  Next: MPIR.Net Rationals,  Prev: Building MPIR.Net,  Up: .Net Interface

13.3 MPIR.Net Integers
======================

 -- Class: HugeInt : IntegerExpression, IDisposable
     The MPIR.Net type for the MPIR multi-precision integer is
     'HugeInt'.  A closely related type is 'IntegerExpression', which is
     returned from all operators and methods whose value semantics are
     to compute another number from the source instance and any
     arguments.  'HugeInt' derives from 'IntegerExpression', and many
     operations are defined on the expression class.  Operations defined
     on 'HugeInt' but not on 'IntegerExpression' are typically those
     that modify the value of the source number itself, and thus
     performing them on an expression is meaningless.  Because through
     inheritance all operations are available on 'HugeInt', the
     descriptions below do not specifically indicate whether each
     operator or method is defined for expressions, or just for
     'HugeInt' instances.  For the sake of brevity, they are listed as
     if they were methods of the 'HugeInt' class.  Visual Studio
     provides Intellisense and immediate feedback to help sort out which
     operations are available on expressions.

   Below is a brief summary of the supported multi-precision integer
methods and operators.  To avoid repetition, implementation details are
ommitted.  Since MPIR native functions are called behind the scenes,
review *note Integer Functions:: for further details about the native
implementations.

 -- Constructor: HugeInt ()
 -- Constructor: HugeInt (int/long N)
 -- Constructor: HugeInt (uint/ulong N)
 -- Constructor: HugeInt (double N)
     Constructs a 'HugeInt' object.  Single-limb constructors vary by
     architecture, 32-bit builds take an 'int' or 'uint' argument,
     64-bit builds take a 'long' or 'ulong'.  Any necessary conversion
     follows the corresponding C function, for example 'double' follows
     'mpz_set_d' (*note Assigning Integers::).

 -- Constructor: HugeInt (string S)
 -- Constructor: HugeInt (string S, int BASE)
     Constructs a 'HugeInt' converted from a string using 'mpz_set_str'
     (*note Assigning Integers::).  If the string is not a valid
     integer, an exception is thrown.

 -- Constructor: HugeInt (IntegerExpression E)
     Evaluates the supplied expression and saves its result to the new
     instance.  Because 'HugeInt' is derived from 'IntegerExpression',
     this constructor can be used to make a copy of an existing
     variable, i.e.  'HugeInt a = new HugeInt(b);' without creating any
     permanent association between them.

 -- Static Method: static HugeInt Allocate (uint/ulong BITS)
 -- Method: void Reallocate (uint/ulong BITS)
     Controls the capacity in bits of the allocated integer.

 -- Property: int AllocatedSize
     Returns the number of limbs currently allocated.

 -- Method: ulong Size ()
     Returns the number of limbs currently used.

 -- Method: long GetLimb (mp_size_t INDEX)
     Returns the specified limb.

 -- Method: bool FitsUlong () //64-bit builds only
 -- Method: bool FitsLong () //64-bit builds only
 -- Method: bool FitsUint ()
 -- Method: bool FitsInt ()
 -- Method: bool FitsUshort ()
 -- Method: bool FitsShort ()
 -- Method: long ApproximateSizeInBase (int BASE)
     Checks whether the number would fit in one of the built-in .Net
     types.

 -- Method: string ToString ()
 -- Method: string ToString (int BASE)
 -- Method: string ToString (int BASE, bool LOWERCASE)
     Returns the string representation of the number.  The default
     'base' is 10, and the parameterless overload is limited to 256
     least significant digits by default, producing a leading ellipsis
     (i.e.  ...12345) when the number has more digits.  This is done to
     prevent huge numbers from unexpectedly consuming large amounts of
     memory in the debugger.  The maximum number of digits output is
     configurable via the 'MpirSettings.ToStringDigits' property, where
     zero means unlimited.  The other overloads always output all
     digits.

 -- Method: int ToInt () //32-bit builds
 -- Method: uint ToUint () //32-bit builds
 -- Method: long ToLong () //64-bit builds
 -- Method: ulong ToUlong () //64-bit builds
 -- Method: double ToDouble ()
 -- Method: double ToDouble ('out' int/long EXP)
     Converts the number to a primitive (built-in) .Net type, assuming
     it fits, which can be determined by calling one of the 'Fits...'
     methods.

 -- Property: IntegerExpression Value
     Getting this property is essentially a no-op, as it returns the
     object instance itself.  This never needs to be done explicitly,
     but is used implicitly in statements like 'a.Value += 5;'

     Setting the 'Value' property evaluates the assigned expression and
     saves the result to the object.

 -- Method: void SetTo (int/long VALUE) // 32/64-bit builds
 -- Method: void SetTo (uint/ulong VALUE) // 32/64-bit builds
 -- Method: void SetTo (double VALUE)
 -- Method: void SetTo (string VALUE)
 -- Method: void SetTo (string VALUE, int BASE)
 -- Method: void SetTo (RationalExpression VALUE)
 -- Method: void SetTo (FloatExpression VALUE)
     Sets the value of existing variable from types other than
     'IntegerExpression'.

 -- Method: void Swap (HugeInt A)
     Swaps the values of the two objects.  This is an O(1) operation.

   Arithmetic operators ('+', '-', '*', '/', '%') are overloaded to
allow integers to participate in expressions much like primitive
integers can.  Single-limb primitive types can be used.  These operators
will also accept 'RationalExpression' arguments, producing a
'RationalExpression' result.  Some expression types expose additional
methods, these are listed below.  Invoking these methods does not
prevent the expression from participating in further expressions.

   Expressions resulting from division or computing a modulo allow
setting an explicit rounding mode:
     c.Value = (a / b).Rounding(RoundingModes.Ceiling) + 4;
     d.Value = (a % b).Rounding(RoundingModes.Floor) + 4;

   Division expressions optionally allow the remainder to be saved:
     c.Value = (a / b).SavingRemainderTo(e) + 4;

   When dividing by a limb, the remainder is a single limb and is saved
to an unsigned limb variable.  However, passing this variable as an
'out' argument would not work because of the deferred evaluation.
Instead, a delegate is passed which is called during evaluation:
     ulong/uint remainder; // 64/32-bit builds
     d.Value = (a / 100).SettingRemainderTo(x => remainder = x) + 4;

   Symmetrically, the modulo expressions ('%') allow the quotient to be
saved:
     c.Value = (a % b).SavingQuotientTo(e).RoundingMode(RoundingModes.Ceiling) + 4;
     ulong/uint quotient; // 64/32-bit builds
     d.Value = (a % 100).SettingQuotientTo(x => quotient = x) + 4;

 -- Method: uint/ulong Mod (uint/ulong DIVISOR)
 -- Method: uint/ulong Mod (uint/ulong DIVISOR, RoundingModes
          ROUNDINGMODE)
     Computes the absolute value of the remainder from division of the
     source number by the specified 'divisor'.  This operation differs
     from using the '%' operator by where the result is saved.  The '%'
     operator returns an expression, and a 'HugeInt' variable is
     required to receive the result when the expression is assigned to
     its 'Value' property.  The 'Mod' method, on the other hand,
     computes and returns the remainder immediately since it's a
     primitive type (single limb), and no destination 'HugeInt' variable
     is needed.

   Operator '^' serves dual purposes: when the right operand is a single
limb, it raises the source number to a power, if the right operand is an
'IntegerExpression' it performs a bitwise XOR.

   Comparison operators ('==', '!=', '<', '<=', '>', '>=') accept
'IntegerExpression', single-limb, or double arguments, but do not accept
'RationalExpression' because that would require an awkward explicit cast
when comparing with null.

 -- Method: int CompareTo (IntegerExpression A)
 -- Method: bool Equals (IntegerExpression A)
     Implement 'IComparable<IntegerExpression>' and
     'IEquatable<IntegerExpression>' for strongly-typed comparisons.

 -- Method: int CompareTo (object A)
 -- Method: bool Equals (object A)
     Implement 'IComparable' and equality check for any object.  These
     accept a 'RationalExpression' as an argument, allowing cross-type
     comparisons not possible with operators.

 -- Method: int GetHashCode ()
     This 'object' override computes the hash code.  This is an O(N)
     operation where N is the number of limbs in use.  Changing a
     number's 'Value' changes its hash code, so this should not be done
     on any object that has been added to a hash table or dictionary.

 -- Method: int CompareAbsTo (IntegerExpression A)
 -- Method: int CompareAbsTo (uint/ulong A)
 -- Method: int CompareAbsTo (double A)
     Compares the absolute value of the number with the operand.

 -- Method: int Sign ()
     Returns the number's sign.

   Bit shift operators ('<<', '>>') accept an unsigned limb operand.

   The right shift ('>>') expression provides a method to compute the
modulo, rather than the default quotient:
     var a = new HugeInt("0x1357");
     Debug.WriteLine((a >> 8).ToString(16)); //prints 13
     Debug.WriteLine((a >> 8).Remainder().ToString(16)); //prints 57

   Bitwize operators ('&', '|', '^', '~') are defined for
'IntegerExpression' operands only.  Note that operator '^' is also
defined for a limb operand, and in that case computes a power.

 -- Method: bool GetBit (uint/ulong POSITION)
 -- Method: void SetBit (uint/ulong POSITION, bool VALUE)
 -- Method: void ComplementBit (uint/ulong POSITION)
     Allows access to individual bits of the number, using a "virtual"
     two's complement representation.

 -- Method: uint/ulong PopCount () // 32/64-bit builds
     Gets the number of set bits in the number.

 -- Method: uint/ulong HammingDistance (IntegerExpression TARGET) //
          32/64-bit builds
     Gets the hamming distance between this number and 'target'.

 -- Method: uint/ulong FindBit (bool VALUE, uint/ulong START) //
          32/64-bit builds
     Scans the number for next set or cleared bit (depending on
     'value').

 -- Method: IntegerExpression Abs ()
     Returns an expression that computes the absolute value of the
     number.

 -- Method: IntegerExpression DivideExactly (IntegerExpression DIVISOR)
 -- Method: IntegerExpression DivideExactly (uint/ulong DIVISOR) //
          32/64-bit builds
     Returns an expression that performs a fast division where it is
     known that there is no remainder.

 -- Method: IntegerExpression PowerMod (IntegerExpression POWER,
          IntegerExpression MODULO)
 -- Method: IntegerExpression PowerMod (uint/ulong POWER,
          IntegerExpression MODULO) // 32/64-bit builds
     Returns an expression that raises the source to the specified
     'power' modulo 'modulo'.

 -- Method: bool IsDivisibleBy (IntegerExpression A)
 -- Method: bool IsDivisibleBy (uint/ulong A)
 -- Method: bool IsDivisibleByPowerOf2 (uint/ulong POWER)
 -- Method: bool IsCongruentTo (IntegerExpression A, IntegerExpression
          MODULO)
 -- Method: bool IsCongruentTo (uint/ulong A, uint/ulong MODULO)
 -- Method: bool IsCongruentToModPowerOf2 (IntegerExpression A,
          uint/ulong POWER)
 -- Method: bool IsPerfectPower ()
 -- Method: bool IsPerfectSquare ()
     Performs various divisibility checks.  These methods return a bool
     result, and therefore are executed immediately.  If they are called
     on an expression, the expression is evaluated to a temporary which
     is discarded immediately afterwards.  If you will need this result
     again, assign the expression to a 'HugeInt' variable and call the
     method on it.

 -- Method: long Write (Stream STREAM)
 -- Method: long Read (Stream STREAM)
     Writes and reads integers to/from streams using the raw binary
     format.

 -- Method: long Write (TextWriter WRITER)
 -- Method: long Write (TextWriter WRITER, int BASE)
 -- Method: long Write (TextWriter WRITER, int BASE, bool LOWERCASE)
 -- Method: long Read (TextReader READER)
 -- Method: long Read (TextReader READER, int BASE)
     Writes and reads integers as text.

 -- Method: void Import<T> (T[] DATA, long LIMBCOUNT, int BYTESPERLIMB,
          LimbOrder LIMBORDER, Endianness ENDIANNESS, int NAILS)
 -- Method: long Export<T> (T[] DATA, int BYTESPERLIMB, LimbOrder
          LIMBORDER, Endianness ENDIANNESS, int NAILS)
 -- Method: T[] Export<T> (int BYTESPERLIMB, LimbOrder LIMBORDER,
          Endianness ENDIANNESS, int NAILS)
     Imports/exports the absolute value of the number to/from arbitrary
     words of data.

 -- Method: bool IsProbablePrime (MpirRandom RANDOM, int PROBABILITY,
          ulong/uint PRETESTED)
 -- Method: bool IsLikelyPrime (MpirRandom RANDOM, ulong/uint PRETESTED)
 -- Static Method: static int Jacobi (HugeInteger A, HugeInteger B)
 -- Static Method: static int Legendre (HugeInteger A, HugeInteger B)
 -- Static Method: static int Kronecker (HugeInteger A, HugeInteger B)
 -- Static Method: static int Kronecker (HugeInteger A, int/long B)
 -- Static Method: static int Kronecker (HugeInteger A, uint/ulong B)
 -- Static Method: static int Kronecker (int/long A, HugeInteger B)
 -- Static Method: static int Kronecker (uint/ulong A, HugeInteger B)
 -- Static Method: static IntegerExpression Power (uint/ulong VALUE,
          uint/ulong POWER)
 -- Static Method: static IntegerExpression Factorial (uint/ulong VALUE)
 -- Static Method: static IntegerExpression Factorial (uint/ulong VALUE,
          uint/ulong ORDER)
 -- Static Method: static IntegerExpression Primorial (uint/ulong VALUE)
 -- Static Method: static IntegerExpression Binomial (uint/ulong N,
          uint/ulong K)
 -- Static Method: static IntegerExpression Binomial (IntegerExpression
          N, uint/ulong K)
     Performs various number-theoretic computations.

 -- Static Method: static IntegerSequenceExpression Fibonacci (int/long
          N)
 -- Static Method: static IntegerSequenceExpression Lucas (int/long N)
     These two methods return a specialized expression that provides an
     additional method to optionally save the previous number in the
     sequence, in addition to the number requested, for example:
          var b = new HugeInt();
          var c = new HugeInt(HugeInt.Fibonacci(300).SavingPreviousTo(b));

 -- Method: IntegerSquareRootExpression SquareRoot ()
     Returns an expression that evaluates to the square root of the
     number.  The expression provides a method to optionally save the
     remainder to a second variable:
          a.Value = b.SquareRoot().SavingRemainderTo(c);

 -- Method: IntegerRootExpression Root (ulong/uint POWER)
     Returns an expression that evaluates to the root of the specified
     'power' of the number.  The expression provides two optional
     methods.  One allows to save the remainder to a second variable,
     and the other allows to set a boolean flag indicating whether the
     root operation was exact.  Note that computing the remainder is
     more costly than just getting an exact flag.
          bool exact = false;
          a.Value = b.Root(3).SavingRemainderTo(r);
          c.Value = d.Root(4).SettingExactTo(x => exact = x);
          e.Value = f.Root(5).SavingRemainderTo(r).SettingExactTo(x => exact = x);

 -- Method: IntegerExpression NextPrimeCandidate (MpirRandom RANDOM)
     Returns an expression that looks for the next possible prime
     greater than the source number.

 -- Method: uint/ulong Gcd (uint/ulong A)
     Computes the greatest common divisor with the specified single-limb
     number.

 -- Method: IntegerGcdExpression Gcd (IntegerExpression A)
     Returns an expression that computes the greatest common divisor of
     the source number and 'a'.  Provides a method to optionally
     calculate the related Diophantine equation multiplier(s):
          c.Value = a.Gcd(b).SavingDiophantineMultipliersTo(s, t);
     If either 's' or 't' is null, that coefficient is not computed.

 -- Method: IntegerExpression Lcm (IntegerExpression A)
 -- Method: IntegerExpression Lcm (uint/ulong A)
     Computes the least common multiple with 'a'.

 -- Method: IntegerExpression Invert (IntegerExpression MODULO)
     Returns an expression to compute the inverse of the source number
     modulo 'modulo'.

 -- Method: IntegerRemoveFactorsExpression RemoveFactors
          (IntegerExpression FACTOR)
     Returns an expression that evaluates to the result of removing all
     occurrences of the specified 'factor' from the source number.
     Provides a method to optionally save the number of factors that
     were removed:
          ulong/uint numberRemoved; // 64/32-bit builds
          a.Value = b.RemoveFactors(c);
          d.Value = e.RemoveFactors(f).SavingCountRemovedTo(x => numberRemoved = x);


File: mpir.info,  Node: MPIR.Net Rationals,  Next: MPIR.Net Floats,  Prev: MPIR.Net Integers,  Up: .Net Interface

13.4 MPIR.Net Rationals
=======================

 -- Class: HugeRational : RationalExpression, IDisposable
     MPIR multi-precision rational numbers are represented by the
     'HugeRational' class, along with its corresponding expression class
     'RationalExpression', which is returned from all operators and
     methods whose value semantics are to compute another number from
     the source instance and any arguments.  Operations defined on
     'HugeRational' but not on 'RationalExpression' are typically those
     that modify the value of the source number itself, and thus
     performing them on an expression is meaningless.  Because through
     inheritance all operations are available on 'HugeRational', the
     descriptions below do not specifically indicate whether each
     operator or method is defined for expressions, or just for
     'HugeRational' instances.  For the sake of brevity, they are listed
     as if they were methods of the 'HugeRational' class.  Visual Studio
     provides Intellisense and immediate feedback to help sort out which
     operations are available on expressions.

   Below is a brief summary of the supported multi-precision rational
methods and operators.  To avoid repetition, implementation details are
ommitted.  Since MPIR native functions are called behind the scenes,
review *note Rational Number Functions:: for further details about the
native implementations.

 -- Constructor: HugeRational ()
 -- Constructor: HugeRational (int/long NUMERATOR, uint/ulong
          DENOMINATOR)
 -- Constructor: HugeRational (uint/ulong NUMERATOR, uint/ulong
          DENOMINATOR)
 -- Constructor: HugeRational (IntegerExpression NUMERATOR,
          IntegerExpression DEMONINATOR)
 -- Constructor: HugeRational (double N)
     Constructs a 'HugeRational' object.  Single-limb constructors vary
     by architecture, 32-bit builds take 'int' or 'uint' arguments,
     64-bit builds take 'long' or 'ulong'.  Any necessary conversion
     follows the corresponding C function, for example 'double' follows
     'mpq_set_d' (*note Initializing Rationals::).

 -- Constructor: HugeRational (string S)
 -- Constructor: HugeRational (string S, int BASE)
     Constructs a 'HugeRational' converted from a string using
     'mpq_set_str' (*note Initializing Rationals::).  If the string is
     not a valid integer or rational, an exception is thrown.

   When constructing a rational number from a numerator and denominator,
including the string constructors where both numerator and denominator
are specified, the fraction should be in canonical form, or if not then
'Canonicalize()' should be called.

 -- Constructor: HugeRational (IntegerExpression E)
 -- Constructor: HugeRational (RationalExpression E)
 -- Constructor: HugeRational (FloatExpression E)
     Evaluates the supplied expression and saves its result to the new
     instance.  Because multi-precision classes are derived from their
     corresponding expression classes, these constructors can be used to
     make a copy of an existing variable, i.e.  'HugeRational a = new
     HugeRational(b);' without creating any permanent association
     between them.

 -- Static Method: static HugeRational Allocate (uint/ulong
          NUMERATORBITS, uint/ulong DENOMINATORBITS)
     Controls the capacity in bits of the allocated integer.
     HugeRational does not have a 'Reallocate' method, but its numerator
     and demonimator are derived from HugeInt and can thus be
     reallocated separately.

 -- Method: void Canonicalize ()
     Puts a 'HugeRational' into canonical form, as per *note Rational
     Number Functions::.  All arithmetic operators require their
     operands in canonical form, and will return results in canonical
     form.

 -- Property: HugeInt Numerator
 -- Property: HugeInt Denominator
     These read-only properties expose the numerator and denominator for
     direct manipulation.  They return specialized instances of the
     'HugeInt' class that do not own their limb data.  They override the
     'Dispose()' method with a no-op, so they can be safely passed
     around as normal integers, even to code that tries to dispose of
     them.

     Once a numerator or denominator is obtained, it remains valid for
     the life of the 'HugeRational' instance.  It references live data,
     so for example, if the 'Value' of the rational is modified, it will
     be visible through a previously obtained numerator/denominator
     instance.  Conversely, setting the 'Value' of a numerator or
     denominator modifies the 'Value' of its owning rational, and if
     this cannot be known to keep the rational in canonical form,
     'Canonicalize()' must be called before performing any further MPIR
     operations on the rational.

     Multiple copies can be safely obtained, and reference the same
     internal structures.  Once the 'HugeRational' is disposed, any
     numerator and denominator instances obtained from it are no longer
     valid.

 -- Method: long ApproximateSizeInBase (int BASE)
     Returns the number of digits the absolute value of number would
     take if written in the specified base.  The result can be at most 2
     characters too long, and allows for a numerator, a division sign,
     and a denominator, but excludes the leading minus sign.

 -- Method: string ToString ()
 -- Method: string ToString (int BASE)
 -- Method: string ToString (int BASE, bool LOWERCASE)
     Returns the string representation of the number.  The default
     'base' is 10, and the parameterless overload is limited to 256
     least significant digits by default, each for a numerator and a
     denominator, producing a leading ellipsis (i.e.  ...12345) when
     either component has more digits.  This is done to prevent huge
     numbers from unexpectedly consuming large amounts of memory in the
     debugger.  The maximum number of digits output is configurable via
     the 'MpirSettings.ToStringDigits' property, where zero means
     unlimited.  The other overloads always output all digits.

 -- Method: double ToDouble ()
     Converts the number to a double, possibly truncated.

 -- Property: RationalExpression Value
     Getting this property is essentially a no-op, as it returns the
     object instance itself.  This never needs to be done explicitly,
     but is used implicitly in statements like 'a.Value += 5;'

     Setting the 'Value' property evaluates the assigned expression and
     saves the result to the object.

 -- Method: void SetTo (int/long VALUE) // 32/64-bit builds
 -- Method: void SetTo (int/long NUMERATOR, uint/ulong DENOMINATOR)
 -- Method: void SetTo (uint/ulong VALUE)
 -- Method: void SetTo (uint/ulong NUMERATOR, uint/ulong DENOMINATOR)
 -- Method: void SetTo (double VALUE)
 -- Method: void SetTo (string VALUE)
 -- Method: void SetTo (string VALUE, int BASE)
 -- Method: void SetTo (IntegerExpression VALUE)
 -- Method: void SetTo (IntegerExpression NUMERATOR, IntegerExpression
          DENOMINATOR)
 -- Method: void SetTo (FloatExpression VALUE)
     Sets the value of existing variable from types other than
     'RationalExpression'.  When setting both the numerator and
     denominator, canonicalization must be managed explicitly.

 -- Method: void Swap (HugeRational A)
     Swaps the values of the two objects.  This is an O(1) operation.
     Any existing numerators and denominators remain associated with the
     object on which they were obtained, and reflect its new value.

   Arithmetic operators ('+', '-', '*', '/') are overloaded to allow
rationals to participate in expressions much like primitive integers
can.  Single-limb primitive types can be used.  These operators will
also accept 'IntegerExpression' arguments, and will automatically
promote them.  In expressions, promotion of an 'IntegerExpression' to a
'RationalExpression' is an O(1) operation.  Of course, when constructing
a rational from an integer, a copy is made so this becomes O(N).

   Due to the rationals' nature, division is always exact (there is no
rounding) and the modulo operator ('%') is not defined.  Also not
defined are the bit shift operators ('<<', '>>'), and the bitwise
operators ('&', '|', '^', '~').

   Operator '^' raises the source number to the specified power.

   Comparison operators ('==', '!=', '<', '<=', '>', '>=') accept
'RationalExpression', single-limb, or double arguments, but do not
accept integer or float expressions because that would require an
awkward explicit cast when comparing with null.  Use the
'CompareTo(object)' method for cross-comparisons.

 -- Method: int CompareTo (RationalExpression A)
 -- Method: bool Equals (RationalExpression A)
     Implement 'IComparable<RationalExpression>' and
     'IEquatable<RationalExpression>' for strongly-typed comparisons.

 -- Method: int CompareTo (object A)
 -- Method: bool Equals (object A)
     Implement 'IComparable' and equality check for any object.  For
     rationals, these methods support any expression type (integer,
     rational, or float).

 -- Method: bool Equals (int/long NUMERATOR, uint/ulong DENOMINATOR)
 -- Method: bool Equals (uint/ulong NUMERATOR, uint/ulong DENOMINATOR)
 -- Method: int CompareTo (int/long NUMERATOR, uint/ulong DENOMINATOR)
 -- Method: int CompareTo (uint/ulong NUMERATOR, uint/ulong DENOMINATOR)
     Single-limb comparisons for rationals take two arguments.

 -- Method: int GetHashCode ()
     This 'object' override computes the hash code.  This is an O(N)
     operation where N is the number of limbs in use in the numerator
     and denominator combined.  Changing a number's 'Value' changes its
     hash code, so this should not be done on any object that has been
     added to a hash table or dictionary.

 -- Method: int Sign ()
     Returns the number's sign.

 -- Method: RationalExpression Abs ()
     Returns an expression that computes the absolute value of the
     number.

 -- Method: RationalExpression Invert ()
     Returns an expression that computes the inverse of the number.

 -- Method: long Write (Stream STREAM)
 -- Method: long Read (Stream STREAM)
     Writes and reads rationals to/from streams using the raw binary
     format.

 -- Method: long Write (TextWriter WRITER)
 -- Method: long Write (TextWriter WRITER, int BASE)
 -- Method: long Write (TextWriter WRITER, int BASE, bool LOWERCASE)
 -- Method: long Read (TextReader READER)
 -- Method: long Read (TextReader READER, int BASE)
     Writes and reads rationals as text.

   There are no 'Import'/'Export' methods, but they can of course be
invoked on the numerator and/or denominator.

   'RationalExpression' does not have any specialized subclasses, as
there are no operations on the rational type that require additional
inputs beyond the left and right operator operands.


File: mpir.info,  Node: MPIR.Net Floats,  Next: MPIR.Net Random Numbers,  Prev: MPIR.Net Rationals,  Up: .Net Interface

13.5 MPIR.Net Floats
====================

 -- Class: HugeFloat : FloatExpression, IDisposable
     The MPIR.Net class for multi-precision floating point numbers is
     'HugeFloat', and its corresponding expression class is
     'FloatExpression', which is returned from all operators and methods
     whose value semantics are to compute another number from the source
     instance and any arguments.  'HugeFloat' derives from
     'FloatExpression', and many operations are defined on the
     expression class.  Operations defined on 'HugeFloat' but not on
     'FloatExpression' are typically those that modify the value of the
     source number itself, and thus performing them on an expression is
     meaningless.  Because through inheritance all operations are
     available on HugeFloat, the descriptions below do not specifically
     indicate whether each operator or method is defined for
     expressions, or just for 'HugeFloat' instances.  For the sake of
     brevity, they are listed as if they were methods of the 'HugeFloat'
     class.  Visual Studio provides Intellisense and immediate feedback
     to help sort out which operations are available on expressions.

   Below is a brief summary of the supported multi-precision rational
methods and operators.  To avoid repetition, implementation details are
ommitted.  Since MPIR native functions are called behind the scenes,
review *note Floating-point Functions:: for further details about the
native implementations.

 -- Static Property: static uint/ulong DefaultPrecision
     Gets or sets the default precision of the floating point mantissa,
     in bits.  If the value is not a multiple of limb size, the actual
     precision will be rounded up.  All newly constructed 'HugeFloat'
     objects that don't explicitly specify precision will use this
     default.  Previously constructed objects are unaffected.  The
     initial default precision is 2 limbs.

     When an expression is evaluated, it is either because it is being
     assigned to some destination variable (e.g.  'a.Value = b + c;') or
     a primitive-computing method is being called (e.g.  'int s = (b +
     c).Sign();') In the former case, the precision of the destination
     is used for all computations and temporaries during expression
     evaluation.  In the latter case, there is no destination so the
     'DefaultPrecision' is used.

 -- Constructor: HugeFloat ()
 -- Constructor: HugeFloat (int/long VALUE)
 -- Constructor: HugeFloat (uint/ulong VALUE)
 -- Constructor: HugeFloat (double N)
     Constructs a 'HugeFloat' object.  Single-limb constructors vary by
     architecture, 32-bit builds take 'int' or 'uint' arguments, 64-bit
     builds take 'long' or 'ulong'.  Any necessary conversion follows
     the corresponding C function, for example 'double' follows
     'mpf_set_d' (*note Initializing Floats::).

 -- Constructor: HugeFloat (string S)
 -- Constructor: HugeFloat (string S, int BASE)
 -- Constructor: HugeFloat (string S, int BASE, bool EXPONENTINDECIMAL)
     Constructs a 'HugeFloat' converted from a string using
     'mpf_set_str' (*note Initializing Floats::).  If the string is not
     a valid integer or floating point number, an exception is thrown.

 -- Constructor: HugeFloat (IntegerExpression VALUE)
 -- Constructor: HugeFloat (RationalExpression VALUE)
 -- Constructor: HugeFloat (FloatExpression VALUE)
     Evaluates the supplied expression and saves its result to the new
     instance.  Because multi-precision classes are derived from their
     corresponding expression classes, these constructors can be used to
     make a copy of an existing variable, i.e.  'HugeFloat a = new
     HugeFloat(b);' without creating any permanent association between
     them.

 -- Static Method: static HugeRational Allocate (uint/ulong PRECISION)
 -- Method: void Reallocate (uint/ulong PRECISION)
     Controls the allocated precision in bits of the new or existing
     'HugeFloat'.

 -- Property: uint/ulong AllocatedPrecision
     Gets the precision in bits that is currently allocated for internal
     storage of the mantissa.  The precision actually in effect, used in
     calculations, is initially the same but may be reduced by setting
     the 'Precision' property.

 -- Property: uint/ulong Precision
     Gets or sets the effective precision of the number without changing
     the memory allocated.  The number of bits cannot exceed the
     precision with which the variable was initialized or last
     reallocated.  The value of the number is unchanged, and in
     particular if it previously had a higher precision it will retain
     that higher precision.  New values assigned to the 'Value' property
     will use the new precision.  The number can be safely disposed
     after modifying its 'Precision' (unlike the native MPIR, which
     requires you to restore the precision to the allocated value before
     the memory can be freed).

 -- Method: bool FitsUlong () //64-bit builds only
 -- Method: bool FitsLong () //64-bit builds only
 -- Method: bool FitsUint ()
 -- Method: bool FitsInt ()
 -- Method: bool FitsUshort ()
 -- Method: bool FitsShort ()
     Checks whether the number would fit in one of the built-in .Net
     types.

 -- Method: bool IsInteger ()
     Checks whether the number is a whole integer.

 -- Method: string ToString ()
 -- Method: string ToString (int BASE)
 -- Method: string ToString (int BASE, bool LOWERCASE)
 -- Method: string ToString (int BASE, bool LOWERCASE, bool
          EXPONENTINDECIMAL)
     Returns the string representation of the number.  The default
     'base' is 10, and the parameterless overload is limited to 256
     mantissa digits by default.  This is done to prevent huge numbers
     from unexpectedly consuming large amounts of memory in the
     debugger.  The maximum number of digits output is configurable via
     the 'MpirSettings.ToStringDigits' property, where zero means
     unlimited.  'MpirSettings.ToStringDigits' applies to integers and
     rationals as well.  The other overloads always output all digits.

 -- Method: int ToInt () //32-bit builds
 -- Method: uint ToUint () //32-bit builds
 -- Method: long ToLong () //64-bit builds
 -- Method: ulong ToUlong () //64-bit builds
 -- Method: double ToDouble ()
 -- Method: double ToDouble ('out' int/long EXP)
     Converts the number to a primitive (built-in) .Net type, assuming
     it fits, which can be determined by calling one of the 'Fits...'
     methods.

 -- Property: FloatExpression Value
     Getting this property is essentially a no-op, as it returns the
     object instance itself.  This never needs to be done explicitly,
     but is used implicitly in statements like 'a.Value += 5;'

     Setting the 'Value' property evaluates the assigned expression and
     saves the result to the object.

 -- Method: void SetTo (int/long VALUE) // 32/64-bit builds
 -- Method: void SetTo (uint/ulong VALUE) // 32/64-bit builds
 -- Method: void SetTo (double VALUE)
 -- Method: void SetTo (string VALUE)
 -- Method: void SetTo (string VALUE, int BASE)
 -- Method: void SetTo (string VALUE, int BASE, bool EXPONENTINDECIMAL)
 -- Method: void SetTo (IntegerExpression VALUE)
 -- Method: void SetTo (RationalExpression VALUE)
     Sets the value of existing variable from types other than
     'FloatExpression'.

 -- Method: void Swap (HugeFloat A)
     Swaps the values (and precisions) of the two objects.  This is an
     O(1) operation.

   Arithmetic operators ('+', '-', '*', '/') and bit shifts ('<<', '>>')
are overloaded to allow floats to participate in expressions much like
primitive types can.  Single-limb primitive types can be used.  These
operators do not accept integer or rational expressions.  There is some
cost of instantiating a floating point number from another
multi-precision type, so to make this point clear MPIR.Net forces you to
use explicit constructors or assignments for this conversion.

   The modulo operator ('%') and the bitwise operators ('&', '|', '^',
'~') are not defined.

   Operator '^' raises the source number to the specified power.

   Comparison operators ('==', '!=', '<', '<=', '>', '>=') accept
'FloatExpression', single-limb, or double arguments, but do not accept
integer or rational expressions because that would require an awkward
explicit cast when comparing with null.

 -- Method: int CompareTo (FloatExpression A)
 -- Method: bool Equals (FloatExpression A)
     Implement 'IComparable<FloatExpression>' and
     'IEquatable<FloatExpression>' for strongly-typed comparisons.

 -- Method: int CompareTo (object A)
 -- Method: bool Equals (object A)
     Implement 'IComparable' and equality check for any object.  These
     support only float expressions or .Net primitive types.  When this
     method is called on a 'HugeFloat' object, comparison is performed
     to the precision of the object.  When called on an expression,
     comparison is performed to the default precision.

 -- Method: int GetHashCode ()
     This 'object' override computes the hash code.  This is an O(N)
     operation where N is the number of limbs allocated.  Changing a
     number's 'Value' changes its hash code, so this should not be done
     on any object that has been added to a hash table or dictionary.

 -- Method: bool Equals (object A, uint/ulong PRECISION)
     Checks for equality using the specified precision.  The argument
     'a' can be a 'FloatExpression' or a primitive type.

 -- Method: FloatExpression RelativeDifferenceFrom (FloatExpression A)
     Returns an expression that computes abs(THIS-A)/THIS

 -- Method: FloatExpression Abs ()
 -- Method: FloatExpression SquareRoot ()
 -- Static Method: static FloatExpression SquareRoot (uint/ulong a)
 -- Method: FloatExpression Floor ()
 -- Method: FloatExpression Ceiling ()
 -- Method: FloatExpression Truncate ()
 -- Method: int Sign ()
     Perform various floating-point operations.

 -- Method: long Write (TextWriter WRITER)
 -- Method: long Write (TextWriter WRITER, int BASE)
 -- Method: long Write (TextWriter WRITER, int BASE, int MAXDIGITS, bool
          LOWERCASE, bool EXPONENTINDECIMAL)
 -- Method: long Read (TextReader READER)
 -- Method: long Read (TextReader READER, int BASE)
 -- Method: long Read (TextReader READER, int BASE, bool
          EXPONENTINDECIMAL)
     Writes and reads floats as text.


File: mpir.info,  Node: MPIR.Net Random Numbers,  Next: MPIR.Net Settings,  Prev: MPIR.Net Floats,  Up: .Net Interface

13.6 MPIR.Net Random Numbers
============================

 -- Class: MpirRandom : IDisposable
     The MPIR.Net class that wraps the MPIR random number functions is
     'MpirRandom'.  It holds an algorithm selection and current state,
     as per 'gmp_randstate_t'.  As the multi-precision classes,
     'MpirRandom' allocates unmanaged memory, and should be disposed of
     via its 'IDisposable' implementation when no longer in use.

 -- Static Method: static MpirRandom Default ()
 -- Static Method: static MpirRandom MersenneTwister ()
 -- Static Method: static MpirRandom LinearCongruential (HugeInt A,
          ulong/uint C, ulong/uint M)
 -- Static Method: static MpirRandom LinearCongruential (ulong/uint
          SIZE)
     In lieu of constructors, 'MpirRandom' uses more descriptive static
     factory methods to create new instances of specific random number
     generator algorithms.

 -- Method: MpirRandom Copy ()
     Creates a new random number generator with a copy of the algorithm
     and state from the source instance.

 -- Method: void Seed (ulong/uint SEED)
 -- Method: void Seed (HugeInt SEED)
     Sets an initial seed value into the random number generator.

 -- Method: ulong/uint GetLimbBits (ulong/uint BITCOUNT)
     Generates a uniformly distributed random number of 'bitCount' bits,
     i.e.  in the range 0 to 2^bitCount-1 inclusive.

 -- Method: ulong/uint GetLimb (ulong/uint MAX)
     Generates a uniformly distributed random number in the range 0 to max-1
     inclusive.

 -- Method: IntegerExpression GetIntBits (ulong/uint BITCOUNT)
 -- Method: IntegerExpression GetIntBitsChunky (ulong/uint BITCOUNT)
     Returns an expression that generates a uniformly distributed random
     integer in the range 0 to 2^bitCount-1, inclusive.

 -- Method: IntegerExpression GetInt (IntegerExpression MAX)
     Returns an expression that generates a uniformly distributed random
     number in the range 0 to max-1 inclusive.

 -- Method: FloatExpression GetFloat ()
     Returns an expression that generates a uniformly distributed random
     float in the range 0 <= n < 1.  As with all float expressions,
     precision of the destination is used when available.

 -- Method: FloatExpression GetFloatBits (ulong/uint BITCOUNT)
     Returns an expression that generates a uniformly distributed random
     float in the range 0 <= n < 1, with the specified number of
     significant mantissa bits.

 -- Method: FloatExpression GetFloatChunky (int MAXEXPONENT)
     Returns an expression that generates a random float with long
     strings of zeros and ones in the binary representation, using the
     precision of the destination.  The argument is the maximum absolute
     value for the exponent of the generated number, expressed in limbs.

 -- Method: FloatExpression GetFloatLimbsChunky (long LIMBCOUNT, int
          MAXEXPONENT)
     Returns an expression that generates a random float with long
     strings of zeros and ones in the binary representation, and the
     specified number of significant limbs in the mantissa.

